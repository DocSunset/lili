<!--- @:~ --->
# lilit: the little literate programming tool

`lilit` is a simple command line program written in portable dependency-free C
that aims to provide the absolute bare minimum of functionality needed to
enable writing programs in a literate programming style.  All `lilit` does is
scan a plain-text file for a handful of control sequences, extract source code
delimited by those control sequences, and output source code files by
recursively expanding the chunks of code thus found. This is clear from the
high level structure of `lilit`'s source code:

```c
// ~#'lilit.c'
~{definitions}

int main(int argc, char ** argv)
{
    ~{setup}
    ~{extract code chunks}
    ~{output tangle chunks recursively}
    return 0;
}
// end lilit.c ~
```

This minimalist approach ensures users of `lilit` can depend on it to continue
working reliably and easily modify the source code to tailor the program to
their specific needs, such as adding support for a particular typesetting
markup.

# what is literate programming?

>Literate programming is a very simple idea: Write a book. And oh, by the
>way, the book has the actual executable source code in it.

>Timothy Daly, 2013. "[Literate Programming in the Large](https://youtu.be/Av0PQDVTP4A)"

Literate programming (first described by [Donald Knuth in his paper introducing
the idea](http://www.literateprogramming.com/knuthweb.pdf)) is a style of
computer programming that prioritizes the relationship between the program
writer and program reader.  The essence of this approach is the position that
computer programs should be written primarily as a form of communication
between humans and only incidentally as a means of instructing computing
machines to perform useful jobs.  

Few would disagree that excellent computer code, in addition to whatever other
positive qualities it may possess, should be easy for any programmer to read
and understand.  Conventionally, this ideal is approached by carefully choosing
variable and class names, breaking up complex subroutines into well-named
functions, writing unit tests that demonstrate how a given subroutine is used,
and so on;  basically, the code itself is written to be self-describing.  After
all, the source code has the final word on what the program does and how it
does it.  Comments, documentation, and any other things besides are all
irreconcilably seperate from the actual logic of the program that the code
describes, and they even run the risk of misleading the reader of a program. As
Robert Martin wrote, "[the proper use of comments is to compensate for our
failure to express ourself in
code.](https://www.goodreads.com/book/show/3735293-clean-code)"

On the other hand, there is much that the code itself may struggle to
communicate or which may even be impossible for the code to communicate.
Programming languages are constrained by the systems they are meant to control,
by the systems that translate from source code to machine code, and so on.
These constraints in turn influence the writers of the source code, the ideas
that they can express through the language, and the ways in which they can
present those ideas.  Source code excels at expressing what the program does
and how it does it. Code often struggles when it comes to communicating why it
does what it does and why it does it in that particular way rather than taking
some other approach.  Almost every programming language provides some mechanism
for embedding natural language comments in the source code, precisely to help
programmers to express that which the code cannot.  Documentation is also
increasingly integrated in programming language tooling.  But both comments and
documentation remain subordinate to the source code. They serve to help the
reader decode the source code.  The source code itself remains supreme, and
often also remains opaque, esoteric, and difficult to understand.

Literate programming proposes to invert this relationship: rather than write a
program with some explanations embedded in it, you craft a piece of writing
with a program embedded in it.  Rather than write comments and documentation
interspersed in source code, write source code interspersed in a natural
language narrative.  Rather than write a program primarily to control the
behavior of a computer and only incidentally to be read by humans, write a
piece of prose primarily to communicate with humans and only incidentally
to be executed by a computer.  This is the theory of literate programming.  

In order to write a literate program, the expressive power of most programming
languages is insufficient.  For this reason, the practice of literate
programming usually involves the use of specialized tooling that allows for
expressing source code embedded in a piece of literature.  These tools allow
the source code to be ordered and explained using the structure that most
naturally expresses the meaning of the program, rather than the order and
structure that is most convenient to the compiler or interpreter.  This
involves, for instance, allowing code chunks to be expressed in any order.

# should I write literate programs?

Proponents of literate programming argue that the style provides numerous
benefits.  The prioritization of communication over execution allows
programmers unfamiliar with a program to understand and take ownership of it,
allowing new team members in a collaborative environment to become productive
contributors to the project more quickly.  Literate programs are
also purportedly more resilient to the passage of time and changing of hands,
as new maintainers of a program are endowed with the knowledge of not only what
and how a program works but also why and what for.  Furthermore, writing the
natural language exposition of a literate program naturally forces the writer
to not only better comprehend the program they are writing but also to write a
program that is fundamentally more comprehensible.  As Donald Knuth writes, "my
programs are not only explained better than ever before; they also are better
programs, because the new methodology encourages me to do a better job."
Literate programming also seems especially well suited to environments in which
understanding the program is as important as the program itself, such as in
academic research where a program is part of research findings.  

However, despite the purported benefits, literate programming has not seen much
mainstream adoption.  Although there have been numerous remarkable success
stories (notably [one book written in a literate programming style that won an
Academy Award](https://www.pbrt.org/)), most programmers do not program in a
literate style.  This may be explained in part by the disadvantages of literate
programming.  

As Knuth recognized in the paper introducing the style, literate programming
practice usually entails writing literate programs in a document that combines
typesetting markup, literate programming specific markup, and source code.
This introduces the opportunity for syntax errors in three different languages
in addition to normal program logic errors, with the associated increase in the
complexity of debugging a literate program. More generally, literate
programming practice introduces additional tooling that necessarily adds some
complexity to writing programs.

Programming in a literate style requires authoring and maintaining not only the
program itself but also the literary work in which the program is embedded.  As
the program changes, it is essential to ensure that the associated literature
is updated with discipline lest it drift out of sync with the actual program
logic it is meant to describe. The cost of maintaining the prose in addition to
the program can be magnified in environments where the requirements for the
program and/or its design may frequently and drastically change.  

However, the most damning challenge to the adoption of literate programming
comes not from the tooling nor the maintenance of prose, but simply from the
fact that programming is hard, writing is hard, and very few people are good at
both.  This means that programmers with aptitude for literate programming are
naturally somewhat rare.

In summary:

Pros:

- Improved readability decreases time for new programmers to integrate into collaborative environments
- Program maintenance is easier especially as old maintainers become separated from the project
- Authoring prose alongside code encourages writing higher quality programs
- Emphasis on communication is a natural fit for e.g. programs produced as part of research

Cons:

- Additional tooling imposes increased debugging and programming environment complexity
- Prose introduces additional maintenance overhead, especially when requirements change quickly
- Writing good programs is hard enough without also having to write good literature

If program requirements are reasonably well defined, if it is common for
newcomers to contribute to a project, if code maintainers are likely to change
over time, if the people involved in a project are reasonably good writers as
well as programmers, and especially if the full and varied meanings of the
source code are as important as the code itself, it may be worthwhile to
consider adopting a literate programming style.

Writing in a literate programming style may seem less useful for beginners,
hobbyists, and other amateurs, who may not have the well define program
requirements and deep understanding of the programs they are writing, and who
generally work alone and so miss out on the collaborative advantages of
literate programming.  However, the same people are very likely to benefit from
more widespread adoption of literate programming, because reading and
understanding a literate program is much easier than doing the same with
programs written in a more conventional style. This is the advantage of
literate programming most exciting to me personally. Literate programs have
great potential as educational tools. In the best case, literate programs can
elevate and empower the reader in a way conventional programs simply can't.

# how does `lilit` work?

The remainder of this document (the literate source code for `lilit`) describes
the functionality and implementation of `lilit`.

`lilit` knows nothing about the machine source code language, has no runtime
configuration or flags, and makes as few assumptions as possible about the
typesetting markup used for prose passages.  Furthermore, `lilit` provides no
functionality for weaving, i.e.  producing typesetting markup from the literate
source code. This functionality is not essential for literate programming,
which is about organization and communication rather than typesetting and
generating cross references (see [this
article](http://akkartik.name/post/literate-programming) for example).  If the
writer wishes to produce a typeset document from the source code, typesetting
markup may be written directly in the lilit-formatted document and the
typesetting system can be run directly on this document. For example, this
literate source document for `lilit` is typeset in Github-flavored Markdown.

Despite its intentional limitations, `lilit` provides enough functionality to
enable writing in a literate programming style.  Code chunks can be presented
to the reader in any order, and code chunks can be referred to by name inside
of other code chunks, allowing for high levels of abstraction in the
presentation of the program.  When outputting source code, chunks are
recursively expanded into the output source files while retaining indentation
for compatibility with white space sensitive languages such as python.

The help text explains the control sequences `lilit` searches for to extract
the machine code embedded in your natural-language document:

```c
// ~='help text'
const char * help =
"lilit: the little literate programming tool -- version %s\n\
\n\
    USAGE: %s file\n\
\n\
    lilit extracts machine source code from literate source code.\n\
\n\
All control sequences begin with a special character called ATSIGN, which is \n\
set to '@' by default. Except for escaped ATSIGNs, all control sequences consume\n\
(i.e. cause to be ignored) the remainder of the line following the end of the\n\
control sequence.\n\
\n\
ATSIGN:new control character  Redefines ATSIGN to whatever immediately follows\n\
                              the : sign. This is useful if your machine source\n\
                              language uses lots of @ signs, for example.\n\
\n\
ATSIGN='chunk name'           Begin a regular chunk declaration. The chunk name\n\
                              must be surrounded by matching single (') or\n\
                              double (") quotes (no backticks). The chunk\n\
                              definition itself begins on the next line.\n\
\n\
ATSIGN#'chunk name'           Begin a tangle chunk declaration. This is similar\n\
                              to a regular chunk, except the name of the chunk\n\
                              is also interpreted as a file name, and the chunk\n\
                              is recursively expanded into the file with that\n\
                              name, overwriting any existing file.\n\
\n\
ATSIGN+'chunk name'           Append to a chunk. The code starting on the\n\
                              next line will be added at the end of the chunk\n\
                              named by 'chunk name'. If no such chunk exists,\n\
                              then one will be created. This is useful e.g. for\n\
                              adding #include directives to the top of a c file.\n\
\n\
ATSIGN{chunk invocation}      Invoke a chunk to be recursively expanded into any\n\
                              tangled output files.\n\
\n\
ATSIGNATSIGN                  Escape sequence. A literal ATSIGN sign with no\n\
                              special meaning to lilit that will be copied as an\n\
                              ATSIGN to any output tangled documents.\n\
\n\
ATSIGN                        Any ATSIGN that isn't followed by one of the above\n\
                              special characters is interpreted as the end of a\n\
                              chunk declaration.\n\
";
// end help text ~
```

## Program Overview

As described in the introduction, `lilit` is implemented with three main
processing stages: setup, extraction, and output. The setup phase reads the
file to be processed into memory. During extraction, the file is scanned for
code chunk definitions, and these are logged in data structures convenient for
output. The output phase then recursively expands code chunks into files.

## Code Chunk Extraction

Extraction proceeds mostly character by character, breaking out into inner
subroutines when an ATSIGN is encountered. ATSIGN is initialized to 64, the
decimal representation of the ASCII character `@` for which the variable is
named.

```c
// ~+'globals'
char ATSIGN = 64; /* ascii for at sign */
// ~
```

While scannign and extracting code chunks, anytime a newline character is
encountered the variable `line_number` is incremented.  `line_number` is
currently only used when printing error messages to help the user find the
location of the error.

```c
// ~+'globals'
int line_number = 0;
// ~
```

The outer-most loop of the extraction phase ignores your literate prose while
scanning for control sequences. When one is found, control passes to the inner
loop where the chunks are actually extracted.

```c
// ~='extract code chunks'
{
    char * s = source;
    
    while (*s != '\0') 
    {
        if (*s == ATSIGN) s = extract_chunk(s, d, &tangles, NULL, NULL, NULL);
        else
        {
            if (*s == '\n') ++line_number;
            ++s;
        }
    }
}
// ~
```

For reference, here is the chunk data structure:

```c
// ~='code chunk struct'
typedef enum ContentType {code, reference} content_t;

typedef struct CodeChunk
{
    char * name;
    char * indent;
    list * contents;
} code_chunk;

typedef struct ChunkContents
{
    char * string;
    size_t indent_size;
    code_chunk * reference;
} chunk_contents;

chunk_contents * code_contents_new(char * code)
{
    chunk_contents * c = malloc(sizeof(chunk_contents));
    c->string = code;
    c->reference = NULL;
    return c;
}

chunk_contents * reference_contents_new(char * indent, size_t size, code_chunk * ref)
{
    chunk_contents * c = malloc(sizeof(chunk_contents));
    c->string = indent;
    c->indent_size = size;
    c->reference = ref;
    return c;
}

content_t contents_type(chunk_contents * c)
{
    if (c->reference == NULL) return code; else return reference;
}

code_chunk * code_chunk_new(char * name)
{
    code_chunk * chunk = malloc(sizeof(code_chunk));
    chunk->name     = name;
    chunk->contents = NULL;
    return chunk;
}
// ~
```

A chunk may be a newly defined passage of code, or a snippet to append to an
existing chunk.  Extracting a chunk means populating the contents list of the
new or existing chunk record with a new null-terminated string. Rather than
duplicating the contents from the file into a newly allocated string, the
contents are instead null-terminated in place by editing the source buffer via
`*s`. 

```c
// ~='extract chunk'
char * extract_chunk(char * s, dict * d, list ** tangles, char * possible_end, char * start_of_line, code_chunk * c)
{
    char * at_the_atsign = s++;
    char type = *s++;
    size_t escape = 0;
    switch (type)
    {
        case '=': case '#': case '+':
            ~{create new chunk or retrieve existing chunk for appending}
            ~{scan to beginning of chunk definition}
            break;

        case ':':
            exit_fail_if (( *s == '=' || *s == '#' || *s == '+' || *s == '{' 
                         || *s == ':' || *s == '\n'), 
                    "Error: cannot redefine ATSIGN to a character used in control sequences on line %d\n", line_number);
            ATSIGN = *s++;
            /* fall through */
        case '{':
            if (c == NULL) /* outside chunk definition */ return s;
            *at_the_atsign = '\0'; /* terminate previous contents list entry */
            if (type == '{')
            {
                ~{extract chunk reference}
            }
            break;

        case '\n':
            exit_fail_if(c == NULL, "Error: chunk termination outside of chunk definition? on line %d\n", line_number);
            *possible_end = '\0';
            return s;

        default:
            if (type == ATSIGN)
            {
                if (c == NULL) return s + 1;
                *at_the_atsign = '\0';
                escape = 1;
            }
    }

    chunk_contents * contents = code_contents_new(s);
    list_append(&(c->contents), (void *)contents);
    s = s + escape;
    possible_end = s;
    ~{scan to the next ATSIGN}
    return extract_chunk(s, d, tangles, possible_end, start_of_line, c);
}
// ~
```

```c
// ~='extract chunk reference'
--s; /* point s at the opening { of the invocation for extract_name */
{
    char * name = extract_name(&s);
    code_chunk * ref = dict_get(d, name);
    if (ref == NULL) /* chunk hasn't been defined yet */
    {
        ref = code_chunk_new(name);
        dict_add(d, ref);
    }
    {
        ~{copy indent string}
        list_append(&(c->contents), 
                (void *)reference_contents_new(indent, size_of_indent, ref));
    }
}
// ~
```

```c
// ~='copy indent string'
char * indent;
char * start = start_of_line;
char * end = start_of_line;
while (isspace(*end)) ++end;
size_t size_of_indent = end - start;
indent = malloc(size_of_indent + 1);
memcpy(indent, start, size_of_indent);
*(indent + size_of_indent) = '\0';
// ~
```

Chunks are terminated by a single ATSIGN followed by a newline; the entire line
ending with this sequence is ignored, which means the last character in a chunk
is always the newline character before this line. For this reason, the position
of each newline encountered while scanning for the end of the chunk is recorded
in the `final_newline_candidate` variable. 

`final_newline_candidate` is initialized to the same position as the beginning
of the chunk, so that a chunk with no contents is correctly extracted as an
empty string.  For example, tangling the following chunk definition should
produce a file which is empty except for a single newline character that is
added to the end of tangle-output chunks to ensure the file ends with a
mewline.

```c
// ~#'test/a_newline.txt'
// ~
```

Scanning for the end of the chunk therefore consists of simply recording the
position of newlines until the terminal ATSIGN is located, plus some error
handling and cruft related to tracking ATSIGNS that I'm planning on refactoring
out.

```c
// ~='scan to the next ATSIGN'
for( ; *s != ATSIGN; ++s)
{
    if (*s == '\n')
    {
        ++line_number;
        start_of_line = possible_end = s+1;
    }
}
// ~
```

Scanning to the beginning of the chunk is even simpler, and basically just has
to be aware of the possibility that the file is malformed and not to loop
forever if the file ends before the chunk definition begins.

I guess if the user was a monster this could encounter difficulty were they to
use a newline as the name delimeter. This could be resolved by moving `s` up to
the name terminator before this loop.

```c
// ~='scan to beginning of chunk definition'
/* s points to the character after ATSIGN/CTRL on entry */
while (*s++ != '\n') /* scan `s` to one past the end of line */
{
    exit_fail_if(*s == '\0', 
            "Error: file ended before beginning the definition of chunk '%s'\n",
            c->name);
}
++line_number;
start_of_line = s;
// ~
```

All that remains is to make a new chunk or retrieve the existing one. Chunks
can be defined with `=`, `#`, or `+`, for a regular new chunk, and new
tangle-output, or additional code to append to an existing chunk respectively.
If `+` is used when the named chunk has not already been defined, this is also
allowed, in which case a new chunk is created in the same way as if `=` had
been used.  Redefining an existing chunk is not allowed.

```c
// ~='create new chunk or retrieve existing chunk for appending'
{
    if (c != NULL) exit_fail_if(1, 
            "Error: definition of chunk within definition of '%s' on line %d\n", 
            c->name);
    char * name = extract_name(&s);
    c = dict_get(d, name);
    if (type == '+' && c != NULL) {} /* appending to an existing chunk */
    else 
    {
        if (c != NULL)
        {
            exit_fail_if(c->contents != NULL,
                    "Error: redefinition of chunk %s on line %d\n", 
                    name, line_number);
        } 
        else 
        {
            c = code_chunk_new(name);
            dict_add(d, c);
        }
        if (type == '#') list_append(tangles, (void *)c);
    }
}
// ~
```

## Code Tangling and Output

Each code chunk recorded in the list of chunks to tangle is output to a file
named the same as the code chunk:

```c
// ~='output tangle chunks recursively'
for(; tangles != NULL; tangles = tangles->successor)
{
    FILE * f;
    code_chunk * c = tangles->data;
    f = fopen(c->name, "w");
    if (f == NULL)
    {
        fprintf(stderr,
                "Warning: failed to open file '%s', skipping tangle '%s'\n",
                c->name, c->name);
        continue;
    }
    code_chunk_print(f, d, c, NULL);
    fclose(f);
}
// ~
```

Outputting tangle chunks is done mainly by `code_chunk_print`, which calls
itself recursively. This function proceeds character by character. Most
characters are simply echoed to the output file.  When a newline is
encountered, this also causes indentation to be printed. 

```c
// ~='code chunk print'
void code_chunk_print(FILE * f, dict * d, code_chunk * c, char * indent, size_t indent_size, size_t indent_mem)
{
    list * l;
    for (l = c->contents; l != NULL; l = l->successor)
    {
        chunk_contents * contents = l->data;
        if (contents_type(contents) == code)
        {
            char * s;
            for (s = contents->string; *s != '\0'; s++)
            {
                fputc(*s, f);
                if (*s == '\n') fprintf(f, indent);
            }
        }
        else if (contents_type(contents) == reference)
        {
            code_chunk * next_c = contents->reference;

            size_t newsize = indent_size + contents->indent_size;
            size_t newmem = newsize + 1;
            if (newsize > indent_size)
            {
                if (newmem > indent_mem) indent = realloc((void *)indent, newsize + 1);
                memcpy((void *)(indent + indent_size), contents->string, contents->indent_size + 1)
            }

            indent_mem = code_chunk_print(f, d, next_c, indent, newsize, indent_mem);

            *(indent + indent_size) = '\0'; /* reset indent */
        }
    }
    return indent_mem;
}
// ~
```

We keep track of indentation so that when a chunk is invoked with leading
space, every line of the expanded chunk is printed with the same amount of
space.  This is necessary in case white space is syntactic as in e.g. python,
and is nice even when white space isn't syntactic just to preserve the
visual structure of the code in the output.

```c
// ~='build the next indent'
char * next_indent;
char tmp;
char * indent_end = start_of_line; 
while (isspace(*indent_end)) ++indent_end;
tmp = *indent_end;
*indent_end = '\0'; /* temporarily terminate line at first non-space char */
next_indent = malloc(strlen(start_of_line) + strlen(indent) + 1);
strcpy(next_indent, indent); /* copy current indent to next_indent */
strcat(next_indent, start_of_line); /* append space from current line to next_indent */
*indent_end = tmp; /* restore first non-space char */
// ~
```

## Extra Details

Read on if you are interested in further details, such as the definition of the
list and dict datatypes, the helper functions, and other minutiae.

```c
// ~='data types'
typedef struct List
{
    void * data;
    struct List * successor;
} list;

/* a list must be initialized with data */
list * list_new(void * d)
{
    list * l = malloc(sizeof(list));
    l->data = d;
    l->successor = NULL;
    return l;
}

void list_free(list * l)
{

}

/* we need a double pointer so that if we are passed lst == NULL we mutate *lst
 * so that it points to a new list. This happens in dict_add if the new chunk
 * is hashed into a bucket not already containing a pointer to a list */
void list_append(list ** lst, void * addend)
{
    list * a = list_new(addend);
    if (*lst == NULL)
    {
        *lst = a;
    }
    else
    {
        list * l = *lst;
        while (l->successor != NULL) l = l->successor; /* go to the end of l */
        l->successor = a;
    }
}

void list_push(list ** lst, void * frame)
{
    list * p = list_new(frame);
    if (*lst == NULL)
    {
        *lst = p;
    }
    else
    {
        list * l = *lst;
        *lst = p;
        p->successor = l;
    }
}

void list_pop(list ** lst)
{
    list * p = *lst)
    if (p == NULL) return;
    list * l = p->successor;
    *lst = l;
    list_free(p);
}

~{code chunk struct}

/* http://www.cse.yorku.ca/~~oz/hash.html */
unsigned long hash(unsigned char *str)
{
    unsigned long hash = 5381;
    int c;

    while ((c = *str++)) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */

    return hash;
}

typedef struct Dict
{
    list ** array;
    size_t size;
} dict;

dict * dict_new(size_t size)
{
    dict * d = malloc(sizeof(dict));
    d->array = malloc(size * sizeof(list));
    memset(d->array, (size_t)NULL, size * sizeof(list));
    d->size = size;
    return d;
}

void dict_add(dict * d, code_chunk * c)
{
    unsigned long h = hash((unsigned char *)c->name) % d->size;
    list_append(&(d->array[h]), (void *) c);
}

code_chunk * dict_get(dict * d, char * name)
{
    unsigned long h = hash((unsigned char *)name) % d->size;
    list * l = d->array[h];
    while (l != NULL)
    {
        code_chunk * c = l->data;
        if (strcmp(name, c->name) == 0) return c;
        else l = l->successor;
    }
    return NULL;
}
~
```

```c
// ~='functions'
void exit_fail_if(int condition, char * message, ...)
{
    if (!condition) return;
    va_list args;
    va_start(args, message);
    fprintf(stderr, message, args);
    va_end(args);
    exit(EXIT_FAILURE);
}

char * extract_name(char ** source)
{
    char * s = *source;
    char terminus = *s++;
    if (terminus == '{') terminus = '}';
    char * destination = s;

    for (; *s != terminus; ++s)
        exit_fail_if ((*s == '\n' || *s == '\0'), 
                "Error: unterminated name on line %d\n", line_number);
    exit_fail_if (destination == s,
                "Error: empty name on line %d\n",
                line_number);

    *s = '\0';
    *source = s + 1;
    return destination;
}

~{extract chunk}

~{code chunk print}
// ~
```

```c
// ~='definitions'
~{includes}

~{globals}

~{data types}

~{functions}

~{help text}
// ~
```

```c
// ~='setup'
~{variables}

~{parse command line arguments}

~{load file into `char * source`}

~{allocate additional memory}
// ~
```

```c
// ~='includes'
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>
// ~
```

```c
// ~='parse command line arguments'
if (argc < 2 || *argv[1] == '-' /* assume -h */) 
{
    fprintf(stderr, help, VERSION, argv[0]);
    exit(EXIT_SUCCESS);
}
char * filename = argv[1];
// ~
```

Since the control sequence leader character can be changed with 'ATSIGN:',
it's necessary to swap all the ATSIGNs that are found while extracting to
some stable character to prevent bugs when tangling and weaving. It is
assumed that ascii 7 (^G, BEL) will never occur in any source code file,
so we can transliterate ATSIGNs to 7 without having to worry about escapes.
If anyone ever tries to run `lilit` on a file with actual ascii 7 embedded in
the text, it will undoubtedly cause errors. If this ever happens, the
solution would be to detect actual ascii 7 while extracting and embed some
kind of escape sequence.

```c
// ~='variables'
int file_size;
char * source;
dict * d;
list * tangles = NULL;
// ~
```

```c
// ~='load file into `char * source`'
{
    FILE * source_file = fopen(filename, "r");
    exit_fail_if ((source_file == NULL), 
            "Error: could not open file %s\n", 
            filename);
    
    /* get file size */
    fseek(source_file, 0L, SEEK_END);
    file_size = ftell(source_file);
    rewind(source_file);
    
    /* copy file into memory */
    source = malloc(1 + file_size); /* one added for null termination */
    fread(source, 1, file_size, source_file); 
    fclose(source_file);
    
    source[file_size] = 0;
}
// ~
```

```c
// ~='allocate additional memory'
d = dict_new(128); /* for storing chunks */
// ~
```

# tests

The main test case for `lilit` is its own literate source (i.e. this document).
Producing `lilit.c` by tangling `lilit.lilit` exercises all of the control
sequences specified in the help text. `lilit` should produce a source file when
run, and the same resulting source file every time it is run. This result
should be the same regardless of which version of lilit is run. These assertions
are tested in the Makefile included in this repository. Simple run `make test`
to ensure `lilit` is working as expected.
