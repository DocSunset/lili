# lilit: the little literate program tangler

Inspired by the many formidable "\*web" literate programming tools, `lilit`
aims to provide the absolute bare minimum of functionality needed to enable
writing programs in a literate programming style.  Specifically, `lilit` will
parse literate source code marked up with simple control sequences in order to
extract embedded machine source code (i.e. `lilit` will "tangle" machine source
code from literate source code).  `lilit` knows nothing about the machine
source code language, has no runtime configuration or flags, and makes as few
assumptions as possible about the typesetting markup used for prose passages.
Furthermore, `lilit` provides no functionality for weaving, i.e. producing
typesetting markup from the literate source code. This functionality is not
essential for literate programming, which is about organization and
communication rather than typesetting and generating cross references (see
[this article](http://akkartik.name/post/literate-programming) for example).  

```c
@:~
~='help text'
const char * help =
"lilit: the little literate programming tool -- version %s\n\
\n\
    USAGE: %s file\n\
\n\
    lilit extracts machine source code from literate source code.\n\
\n\
Control sequences are permitted to appear at any point in the source file, \n\
except for flags which must appear inside of a code chunk. All control sequences\n\
begin with a special character called ATSIGN, which is set to '@' by default.\n\
\n\
\n\
ATSIGN:new control character  Redefines ATSIGN to whatever immediately follows\n\
                              the : sign. This is useful if your machine source\n\
                              has lots of @ signs, for example.\n\
\n\
ATSIGN='chunk name'           Begin a regular chunk declaration.\n\
\n\
ATSIGN#'chunk name'           Begin a tangle chunk declaration. This is similar\n\
                              to a regular chunk, except the name of the chunk\n\
                              is also interpreted as a file name, and the chunk\n\
                              is recursively expanded into the file with that\n\
                              name, overwriting any existing file.\n\
\n\
ATSIGN                        End a chunk declaration. The ATSIGN must be \n\
                              immediately followed by a newline character or the\n\
                              end of the file without intervening white space.\n\
                              The whole line on which the terminating ATSIGN is\n\
                              found is ignored, i.e. not considered part of the\n\
                              chunk definition.\n\
\n\
ATSIGN{chunk invocation}      Invoke a chunk to be recursively expanded into any\n\
                              tangled output files.\n\
\n\
ATSIGNATSIGN                  Escape sequence. A literal ATSIGN sign with no\n\
                              special meaning to lilit that will be copied as an\n\
                              ATSIGN to any output tangled documents.\n\
";
~
```

## Program Overview

The remainder of this document (which is the literate source code for `lilit`)
describes the implementation of this tool.  

The program takes two passes over the data: extraction and output.

```c
~#'lilit.c'
~{definitions}

int main(int argc, char ** argv)
{
    ~{setup}
    ~{extract code chunks}
    ~{output tangle chunks recursively}
    return 0;
}
~
```

## Code Chunk Extraction

Extraction proceeds mostly character by character, breaking out into inner
subroutines when an ATSIGN is encountered.

While extracting code chunks, anytime a newline character is encountered the
global variable `line_number` is incremented. `line_number` is currently only
used when printing error messages to help the user find the location of the
error.

```c
~='extract code chunks'
{
    char * s = source;
    
    while (*s != '\0') 
    {
        if (*s == '\n')
        {
            ++line_number;
        }
        else if (*s == ATSIGN)
        {
            ~{keep track of changing ATSIGNs}
            ++s;

            if (*s == '=' || *s == '#')
            {
                ~{extract chunk}
            }
            else if (*s == ':')
            {
                ~{change ATSIGN}
            }
        }
        ++s;
    }
}
~
```

Changing the `ATSIGN` character is straightforward to understand, so here it is
in full.

```c
~='change ATSIGN'
++s;
exit_fail_if (( *s == ':' || *s == '=' || *s == '#' || *s == '\n' || *s == '{' ),
            "Error: cannot redefine ATSIGN to a character used in control sequences on line %d\n",
            line_number);
ATSIGN = *s;
~
```

Although changing ATSIGN is simple, allowing ATSIGN to be dynamically changed
does introduce a bit of complexity.  Code chunk invocations are rediscovered
when outputting tangles.  Suppose that ATSIGN is changed at the beginning of
the file to '!'.  All of the code invocations in the first half of the document
use ATSIGN = '!'.  Then ATSIGN is redefined to '&', and the code chunks in the
latter half of the program use '&'. When its time to output the tangle, the
variable ATSIGN will still be equal to '&', so if the output subroutine is
looking for ATSIGN it will miss all of the code invocations from the first half
of the file, which were invoked with a '!'.

To resolve this issue, ATSIGNs are converted to CTRL so that we can find them
again later even in case ATSIGN is changed to some other character in the
interim. CTRL is chosen to be a character unlikely to appear in any source
code.

```c
~='keep track of changing ATSIGNs'
*s = CTRL; /* set ATSIGN to CTRL and increment s */
~
```

The inner chunk extraction subroutine works similarly to the outer one, but
does the actual work of extracting a single chunk and recording it for easy
access when outputting tangles.

For reference, here is the chunk data structure:

```c
~='code chunk struct'
typedef struct CodeChunk
{
    char * name;
    char * contents;
    int tangle;
} code_chunk;

/* every code chunk must have a name */
code_chunk * code_chunk_new(char * name)
{
    code_chunk * chunk = malloc(sizeof(code_chunk));
    chunk->name     = name;
    chunk->contents = NULL;
    chunk->tangle   = 0;
    return chunk;
}
~
```

Extracting the chunk means filling the contents pointer with a null terminated
string. Rather than duplicating the contents from the file into a newly allocated string, the
contents are instead null-terminated in place by editing the source buffer via
`*s`. 

When the chunk definition begins, `contents` is set to the value of `s` at the
beginning of the first line of code.  When the terminal `ATSIGN` is found,
the contents are null terminated at the position of the newline character on
the final line (i.e. the line before the line containing the terminal ATSIGN).
The chunk is then added to the global chunk dictionary `d`, and if the chunk
was marked for tangling, also to the global list `tangles`.  (Actually neither
`d` nor `tangles` are strictly global, but rather are declared in the `main`
function.)

```c
~='extract chunk'
/* s points to the character after ATSIGN/CTRL on entry */
char * final_newline_candidate;
int tangle = *s++ == '#'; /* 'ATSIGN#' means tangle */
char terminus = *s++; /* chunk name should be 'wrapped' in "matching" *characters* */
code_chunk * c = code_chunk_new(extract_name(s, terminus));
c->tangle = tangle;

while (*s++ != '\n') {} /* scan `s` to one past the end of line */
c->contents = s;
final_newline_candidate = s - 1;

while(1)
{
    if (*s == '\n')
    {
        ++line_number;
        final_newline_candidate = s;
    }
    else if (*s == ATSIGN) 
    {
        ~{keep track of changing ATSIGNs}
        ++s;
        if (*s == ATSIGN) {} /* escape, skip over the second ATSIGN */
                             /* so it won't be turned into a CTRL*/
        else if (*s == '\n' || *s == '\0')
        {
            /* end and record chunk */
            *final_newline_candidate = '\0'; /* yes, it was the final newline */
                                             /* null terminate the contents */
            dict_add(d, c);
            if (c->tangle) list_append(&tangles, (void *)c);
            break;
        }
    }
    else exit_fail_if ((*s == '\0'),
                "Error: file ended during definition of chunk '%s'\n",
                c->name);
    ++s;
}
~
```

## Code Tangling and Output

Each code chunk recorded in the list of chunks to tangle is output to a file
named the same as the code chunk:

```c
~='output tangle chunks recursively'
for(; tangles != NULL; tangles = tangles->successor)
{
    FILE * f;
    code_chunk * c = tangles->data;
    f = fopen(c->name, "w");
    if (f == NULL)
    {
        fprintf(stderr,
                "Warning: failed to open file '%s', skipping tangle '%s'\n",
                c->name, c->name);
        continue;
    }
    code_chunk_print(f, d, c, "");
    fclose(f);
}
~
```

Outputting tangle chunks is done mainly by `code_chunk_print`, which calls
itself recursively. This function proceeds character by character, handling
code invocations and escape sequences specially. When a newline is encountered,
this also causes indentation to be printed. The start of each line is also
noted to facilitate keeping track of indentation when recursively expanding
chunks.

```c
~='code chunk print'
void code_chunk_print(FILE * f, dict * d, code_chunk * c, char * indent)
{
    char * s = c->contents;
    char * start_of_line = s;
    while (*s != '\0')
    {
        if (*s == CTRL)
        {
            ++s;
            if (*s != '{') fputc(*s, f); /* escaped ATSIGN, print it */
            else /* this must be a code invocation */
            {
                char * name = extract_name(++s, '}');
                code_chunk * next_c = dict_get(d, name);

                if (next_c == NULL)
                {
                    fprintf(stderr,
                            "Warning: invocation of chunk '%s' could not be found\n",
                            name);
                }
                else 
                {
                    ~{build the next indent}
            
                    code_chunk_print(f, d, next_c, next_indent);
                }
                while(*s != '}') ++s; /* scan s to the '}' */
                /* fall through to the outer ++s so s points after the '}' */
            }
        }
        else 
        {
            fputc(*s, f);
            if (*s == '\n') 
            {
                /* we can assume there is always another line after a '\n'
                 * because there is never a '\n' on the final line */
                start_of_line = s + 1;
                fprintf(f, "%s", indent); /* print indent on the new line */
            }
        }
        ++s;
    }
}
~
```

We keep track of indentation so that when a chunk is invoked with leading
space, every line of the expanded chunk is printed with the same amount of
space.  This is necessary in case white space is syntactic as in e.g. python,
and is nice even when white space isn't syntactic just to preserve the
visual structure of the code in the output.

```c
~='build the next indent'
char * next_indent;
char tmp;
char * indent_end = start_of_line; 
while (isspace(*indent_end)) ++indent_end;
tmp = *indent_end;
*indent_end = '\0'; /* temporarily terminate line at first non-space char */
next_indent = malloc(strlen(start_of_line) + strlen(indent) + 1);
strcpy(next_indent, indent); /* copy current indent to next_indent */
strcat(next_indent, start_of_line); /* append space from current line to next_indent */
*indent_end = tmp; /* restore first non-space char */
~
```

## Extra Details

Read on if you are interested in further details, such as the definition of the
list and dict datatypes, the helper function `extract_name`, and other
minutiae.

This function is used both to get the name of chunk when extracting chunks, and
to get the name of an invocation when outputting tangled code. `s` points to the
first character of the name, and terminus is the character expected to mark
the end of the name (e.g. '}' in the case of code invocations)

```c
~='data types'
~{code chunk struct}

typedef struct List
{
    void * data;
    struct List * successor;
} list;

/* a list must be initialized with data */
list * list_new(void * d)
{
    list * l = malloc(sizeof(list));
    l->data = d;
    l->successor = NULL;
    return l;
}

void list_append(list ** lst, void * addend)
{
    list * a = list_new(addend);
    if (*lst == NULL)
    {
        *lst = a;
    }
    else
    {
        list * l = *lst;
        while (l->successor != NULL) l = l->successor; /* go to the end of l */
        l->successor = a;
    }
}

/* http://www.cse.yorku.ca/~~oz/hash.html */
unsigned long hash(unsigned char *str)
{
    unsigned long hash = 5381;
    int c;

    while ((c = *str++)) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */

    return hash;
}

typedef struct Dict
{
    list ** array;
    size_t size;
} dict;

dict * dict_new(size_t size)
{
    dict * d = malloc(sizeof(dict));
    d->array = malloc(size * sizeof(list));
    memset(d->array, (size_t)NULL, size * sizeof(list));
    d->size = size;
    return d;
}

void dict_add(dict * d, code_chunk * c)
{
    unsigned long h = hash((unsigned char *)c->name) % d->size;
    list_append(&(d->array[h]), (void *) c);
}

code_chunk * dict_get(dict * d, char * name)
{
    unsigned long h = hash((unsigned char *)name) % d->size;
    list * l = d->array[h];
    while (l != NULL)
    {
        code_chunk * c = l->data;
        if (strcmp(name, c->name) == 0) return c;
        else l = l->successor;
    }
    return NULL;
}
~
```

```c
~='functions'
void exit_fail_if(int condition, char * message, ...)
{
    if (!condition) return;
    va_list args;
    va_start(args, message);
    fprintf(stderr, message, args);
    va_end(args);
    exit(EXIT_FAILURE);
}

char * extract_name(char * s, char terminus)
{
    char * destination;
    char * selection_start = s;
    char * selection_end;

    while(1)
    {
        if (*s == terminus)
        {
            selection_end = s;
            break;
        }
        else exit_fail_if ((*s == '\n' || *s == '\0'),
                    "Error: unterminated name on line %d\n",
                    line_number);
        ++s;
    }

    exit_fail_if ((selection_end == selection_start),
                "Error: empty name on line %d\n",
                line_number);

    *selection_end = '\0';
    destination = malloc(strlen(selection_start) + 1);
    strcpy(destination, selection_start);
    *selection_end = terminus;
    return destination;
}

~{code chunk print}
~
```

```c
~='definitions'
~{includes}

~{globals}

~{data types}

~{functions}

~{help text}
~
```

```c
~='setup'
~{variables}

~{parse command line arguments}

~{load file into `char * source`}

~{allocate additional memory}
~
```

```c
~='includes'
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>
~
```

```c
~='parse command line arguments'
if (argc < 2 || *argv[1] == '-' /* assume -h */) 
{
    fprintf(stderr, help, VERSION, argv[0]);
    exit(EXIT_SUCCESS);
}
char * filename = argv[1];
~
```

Since the control sequence leader character can be changed with 'ATSIGN:',
it's necessary to swap all the ATSIGNs that are found while extracting to
some stable character to prevent bugs when tangling and weaving. It is
assumed that ascii 7 (^G, BEL) will never occur in any source code file,
so we can transliterate ATSIGNs to 7 without having to worry about escapes.
If anyone ever tries to run `lilit` on a file with actual ascii 7 embedded in
the text, it will undoubtedly cause errors. If this ever happens, the
solution would be to detect actual ascii 7 while extracting and embed some
kind of escape sequence.

```c
~='globals'
char ATSIGN = 64; /* ascii for at sign */
const char CTRL = 7; /* ascii ^G, aka BEL */
int line_number = 0;
~
```

```c
~='variables'
int file_size;
char * source;
dict * d;
list * tangles = NULL;
~
```

```c
~='load file into `char * source`'
{
    FILE * source_file = fopen(filename, "r");
    exit_fail_if ((source_file == NULL), 
            "Error: could not open file %s\n", 
            filename);
    
    /* get file size */
    fseek(source_file, 0L, SEEK_END);
    file_size = ftell(source_file);
    rewind(source_file);
    
    /* copy file into memory */
    source = malloc(1 + file_size); /* one added for null termination */
    fread(source, 1, file_size, source_file); 
    fclose(source_file);
    
    source[file_size] = 0;
}
~
```

```c
~='allocate additional memory'
d = dict_new(128); /* for storing chunks */
~
```
