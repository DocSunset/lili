<!--- @:~ --->
# lilit: the little literate programming tool

`lilit` is a simple command line program written in portable dependency-free C
that aims to provide the absolute bare minimum of functionality needed to
enable writing programs in a literate programming style.  All `lilit` does is
scan a plain-text file for a handful of control sequences, extract source code
delimited by those control sequences, and output source code files by
recursively expanding the chunks of code thus found. This is clear from the
high level structure of `lilit`'s source code:

```c
// ~#'lilit.c'
~{definitions}

int main(int argc, char ** argv)
{
    ~{setup}
    ~{extract code chunks}
    ~{output tangle chunks recursively}
    return 0;
}
// end lilit.c ~
```

This minimalist approach ensures users of `lilit` can depend on it to continue
working reliably and easily modify the source code to tailor the program to
their specific needs, such as adding support for a particular typesetting
markup.

# what is literate programming?

>Literate programming is a very simple idea: Write a book. And oh, by the
>way, the book has the actual executable source code in it.

>Timothy Daly, 2013. "[Literate Programming in the Large](https://youtu.be/Av0PQDVTP4A)"

Literate programming (first described by [Donald Knuth in his paper introducing
the idea](http://www.literateprogramming.com/knuthweb.pdf)) is a style of
computer programming that prioritizes the relationship between the program
writer and program reader.  The essence of this approach is the position that
computer programs should be written primarily as a form of communication
between humans and only incidentally as a means of instructing computing
machines to perform useful jobs.  

Few would disagree that excellent computer code, in addition to whatever other
positive qualities it may possess, should be easy for any programmer to read
and understand.  Conventionally, this ideal is approached by carefully choosing
variable and class names, breaking up complex subroutines into well-named
functions, writing unit tests that demonstrate how a given subroutine is used,
and so on;  basically, the code itself is written to be self-describing.  After
all, the source code has the final word on what the program does and how it
does it.  Comments, documentation, and any other things besides are all
irreconcilably seperate from the actual logic of the program that the code
describes, and they even run the risk of misleading the reader of a program. As
Robert Martin wrote, "[the proper use of comments is to compensate for our
failure to express ourself in
code.](https://www.goodreads.com/book/show/3735293-clean-code)"

On the other hand, there is much that the code itself may struggle to
communicate or which may even be impossible for the code to communicate.
Programming languages are constrained by the systems they are meant to control,
by the systems that translate from source code to machine code, and so on.
These constraints in turn influence the writers of the source code, the ideas
that they can express through the language, and the ways in which they can
present those ideas.  Source code excels at expressing what the program does
and how it does it. Code often struggles when it comes to communicating why it
does what it does and why it does it in that particular way rather than taking
some other approach.  Almost every programming language provides some mechanism
for embedding natural language comments in the source code, precisely to help
programmers to express that which the code cannot.  Documentation is also
increasingly integrated in programming language tooling.  But both comments and
documentation remain subordinate to the source code. They serve to help the
reader decode the source code.  The source code itself remains supreme, and
often also remains opaque, esoteric, and difficult to understand.

Literate programming proposes to invert this relationship: rather than write a
program with some explanations embedded in it, you craft a piece of writing
with a program embedded in it.  Rather than write comments and documentation
interspersed in source code, write source code interspersed in a natural
language narrative.  Rather than write a program primarily to control the
behavior of a computer and only incidentally to be read by humans, write a
piece of prose primarily to communicate with humans and only incidentally
to be executed by a computer.  This is the theory of literate programming.  

In order to write a literate program, the expressive power of most programming
languages is insufficient.  For this reason, the practice of literate
programming usually involves the use of specialized tooling that allows for
expressing source code embedded in a piece of literature.  These tools allow
the source code to be ordered and explained using the structure that most
naturally expresses the meaning of the program, rather than the order and
structure that is most convenient to the compiler or interpreter.  This
involves, for instance, allowing code chunks to be expressed in any order.

# should I write literate programs?

Proponents of literate programming argue that the style provides numerous
benefits.  The prioritization of communication over execution allows
programmers unfamiliar with a program to understand and take ownership of it,
allowing new team members in a collaborative environment to become productive
contributors to the project more quickly.  Literate programs are
also purportedly more resilient to the passage of time and changing of hands,
as new maintainers of a program are endowed with the knowledge of not only what
and how a program works but also why and what for.  Furthermore, writing the
natural language exposition of a literate program naturally forces the writer
to not only better comprehend the program they are writing but also to write a
program that is fundamentally more comprehensible.  As Donald Knuth writes, "my
programs are not only explained better than ever before; they also are better
programs, because the new methodology encourages me to do a better job."
Literate programming also seems especially well suited to environments in which
understanding the program is as important as the program itself, such as in
academic research where a program is part of research findings.  

However, despite the purported benefits, literate programming has not seen much
mainstream adoption.  Although there have been numerous remarkable success
stories (notably [one book written in a literate programming style that won an
Academy Award](https://www.pbrt.org/)), most programmers do not program in a
literate style.  This may be explained in part by the disadvantages of literate
programming.  

As Knuth recognized in the paper introducing the style, literate programming
practice usually entails writing literate programs in a document that combines
typesetting markup, literate programming specific markup, and source code.
This introduces the opportunity for syntax errors in three different languages
in addition to normal program logic errors, with the associated increase in the
complexity of debugging a literate program. More generally, literate
programming practice introduces additional tooling that necessarily adds some
complexity to writing programs.

Programming in a literate style requires authoring and maintaining not only the
program itself but also the literary work in which the program is embedded.  As
the program changes, it is essential to ensure that the associated literature
is updated with discipline lest it drift out of sync with the actual program
logic it is meant to describe. The cost of maintaining the prose in addition to
the program can be magnified in environments where the requirements for the
program and/or its design may frequently and drastically change.  

However, the most damning challenge to the adoption of literate programming
comes not from the tooling nor the maintenance of prose, but simply from the
fact that programming is hard, writing is hard, and very few people are good at
both.  This means that programmers with aptitude for literate programming are
naturally somewhat rare.

In summary:

Pros:

- Improved readability decreases time for new programmers to integrate into collaborative environments
- Program maintenance is easier especially as old maintainers become separated from the project
- Authoring prose alongside code encourages writing higher quality programs
- Emphasis on communication is a natural fit for e.g. programs produced as part of research

Cons:

- Additional tooling imposes increased debugging and programming environment complexity
- Prose introduces additional maintenance overhead, especially when requirements change quickly
- Writing good programs is hard enough without also having to write good literature

If program requirements are reasonably well defined, if it is common for
newcomers to contribute to a project, if code maintainers are likely to change
over time, if the people involved in a project are reasonably good writers as
well as programmers, and especially if the full and varied meanings of the
source code are as important as the code itself, it may be worthwhile to
consider adopting a literate programming style.

Writing in a literate programming style may seem less useful for beginners,
hobbyists, and other amateurs, who may not have the well define program
requirements and deep understanding of the programs they are writing, and who
generally work alone and so miss out on the collaborative advantages of
literate programming.  However, the same people are very likely to benefit from
more widespread adoption of literate programming, because reading and
understanding a literate program is much easier than doing the same with
programs written in a more conventional style. This is the advantage of
literate programming most exciting to me personally. Literate programs have
great potential as educational tools. In the best case, literate programs can
elevate and empower the reader in a way conventional programs simply can't.

# how does `lilit` work?

The remainder of this document (the literate source code for `lilit`) describes
the functionality and implementation of `lilit`.

`lilit` knows nothing about the machine source code language, has no runtime
configuration or flags, and makes as few assumptions as possible about the
typesetting markup used for prose passages.  Furthermore, `lilit` provides no
functionality for weaving, i.e.  producing typesetting markup from the literate
source code. This functionality is not essential for literate programming,
which is about organization and communication rather than typesetting and
generating cross references (see [this
article](http://akkartik.name/post/literate-programming) for example).  If the
writer wishes to produce a typeset document from the source code, typesetting
markup may be written directly in the lilit-formatted document and the
typesetting system can be run directly on this document. For example, this
literate source document for `lilit` is typeset in Github-flavored Markdown.

Despite its intentional limitations, `lilit` provides enough functionality to
enable writing in a literate programming style.  Code chunks can be presented
to the reader in any order, and code chunks can be referred to by name inside
of other code chunks, allowing for high levels of abstraction in the
presentation of the program.  When outputting source code, chunks are
recursively expanded into the output source files while retaining indentation
for compatibility with white space sensitive languages such as python.

The help text explains the control sequences `lilit` searches for to extract
the machine code embedded in your natural-language document:

```c
// ~='help text'
const char * help =
"lilit: the little literate programming tool -- version %s\n\
\n\
    USAGE: %s file\n\
\n\
    lilit extracts machine source code from literate source code.\n\
\n\
All control sequences begin with a special character called ATSIGN, which is \n\
set to '@' by default. Except for escaped ATSIGNs, all control sequences consume\n\
(i.e. cause to be ignored) the remainder of the line following the end of the\n\
control sequence.\n\
\n\
ATSIGN:new control character  Redefines ATSIGN to whatever immediately follows\n\
                              the : sign. This is useful if your machine source\n\
                              language uses lots of @ signs, for example.\n\
\n\
ATSIGN='chunk name'           Begin a regular chunk declaration. The chunk name\n\
                              must be surrounded by matching single (') or\n\
                              double (") quotes (no backticks). The chunk\n\
                              definition itself begins on the next line.\n\
\n\
ATSIGN#'chunk name'           Begin a tangle chunk declaration. This is similar\n\
                              to a regular chunk, except the name of the chunk\n\
                              is also interpreted as a file name, and the chunk\n\
                              is recursively expanded into the file with that\n\
                              name, overwriting any existing file.\n\
\n\
ATSIGN+'chunk name'           Append to a chunk. The code starting on the\n\
                              next line will be added at the end of the chunk\n\
                              named by 'chunk name'. If no such chunk exists,\n\
                              then one will be created. This is useful e.g. for\n\
                              adding #include directives to the top of a c file.\n\
\n\
ATSIGN{chunk invocation}      Invoke a chunk to be recursively expanded into any\n\
                              tangled output files.\n\
\n\
ATSIGNATSIGN                  Escape sequence. A literal ATSIGN sign with no\n\
                              special meaning to lilit that will be copied as an\n\
                              ATSIGN to any output tangled documents.\n\
\n\
ATSIGN                        Any ATSIGN that isn't followed by one of the above\n\
                              special characters is interpreted as the end of a\n\
                              chunk declaration.\n\
";
// end help text ~
```

## Program Overview

As described in the introduction, `lilit` is implemented with three main
processing stages: setup, extraction, and output. The setup phase reads the
file to be processed into memory. During extraction, the file is scanned for
code chunk definitions, and these are logged in data structures convenient for
output. The output phase then recursively expands code chunks into files.

## Code Chunk Extraction

Extraction proceeds mostly character by character, breaking out into inner
subroutines when an ATSIGN is encountered. ATSIGN is initialized to 64, the
decimal representation of the ASCII character `@` for which the variable is
named.

```c
// ~+'globals'
char ATSIGN = 64; /* ascii for at sign */
// ~
```

While scannign and extracting code chunks, anytime a newline character is
encountered the variable `line_number` is incremented.  `line_number` is
currently only used when printing error messages to help the user find the
location of the error.

```c
// ~+'globals'
int line_number = 0;
// ~
```

The outer-most loop of the extraction phase ignores your literate prose while
scanning for control sequences. When one is found, control passes to the inner
loop where the chunks are actually extracted.

```c
// ~='extract code chunks'
{
    char * s = source;
    
    while (*s != '\0') 
    {
        if (*s == '\n')
        {
            ++line_number;
        }
        else if (*s == ATSIGN)
        {
            ~{keep track of changing ATSIGNs}
            ++s;

            if (*s == '=' || *s == '#' || *s == '+')
            {
                ~{extract chunk}
            }
            else if (*s == ':')
            {
                ++s;
                exit_fail_if (( *s == ':' || *s == '=' || *s == '#' || *s == '\n' || *s == '{'  || *s == '+'),
                            "Error: cannot redefine ATSIGN to a character used in control sequences on line %d\n",
                            line_number);
                ATSIGN = *s;
            }
        }
        ++s;
    }
}
// ~
```

After changing ATSIGN, the scanner will search for the new ATSIGN character, which
presumably is no longer an `@` but some other character.

Although changing ATSIGN is simple, allowing this change introduces some
complexity down the line. This is because the program scans for ATSIGN
characters while tangling the output in order to find code chunk invocations.
Suppose that ATSIGN is changed at the beginning of the file to '!'.  All of the
code invocations in the first half of the document use ATSIGN = '!'.  Then
ATSIGN is redefined to '&', and the code chunks in the latter half of the
program use '&'. When it's time to output the tangle, the variable ATSIGN will
still be equal to '&', so if the output subroutine is looking for ATSIGN it
will miss all of the code invocations from the first half of the file, which
were invoked with '!'.

To resolve this issue, ATSIGNs are converted to a single unique character,
CTRL, so that we can find them again later even in case ATSIGN is changed to
some other character in the interim. All ATSIGNs found in the first scanning
pass for extraction are converted to CTRL. Then, during the second scanning
pass for output, the program scans for CTRL instead of ATSIGN. CTRL is chosen
to be a character unlikely to appear in any source code.

```c
// ~+'globals'
const char CTRL = 7; /* ascii ^G, aka BEL */
// ~
```

```c
// ~='keep track of changing ATSIGNs'
*s = CTRL; /* set ATSIGN to CTRL s */
// ~
```

The inner chunk extraction subroutine works similarly to the outer one, but
does the actual work of extracting a single chunk and recording it for easy
access when outputting tangles.

For reference, here is the chunk data structure:

```c
// ~='code chunk struct'
typedef struct CodeChunk
{
    char * name;
    list * contents;
    int tangle;
} code_chunk;

/* every code chunk must have a name */
code_chunk * code_chunk_new(char * name)
{
    code_chunk * chunk = malloc(sizeof(code_chunk));
    chunk->name     = name;
    chunk->contents = NULL;
    chunk->tangle   = 0;
    return chunk;
}
// ~
```

Extracting the chunk means adding a pointer to a null terminated string to the
contents list. Rather than duplicating the contents from the file into a newly
allocated string, the contents are instead null-terminated in place by editing
the source buffer via `*s`. 

When the chunk definition begins, the new contents pointer is set to the value
of `s` when it points to the beginning of the first line of code.  When the
terminal `ATSIGN` is found, the contents are null terminated at the position of
the newline character on the final line (i.e. the line before the line
containing the terminal ATSIGN).  Because we won't know whether any given
newline character is the final one until we reach the next line, we keep track
of every newline as a candidate final newline. In case the chunk definition is
empty, we also consider the beginning of the contents pointer as a candidate
end position. If the chunk is empty, then the contents string will be empty,
i.e. the `char *` will point to a `\0` character.

Once the contents string is null terminated, it is added to the contents list
of the chunk. If the chunk was newly defined, it is then added to the global
chunk dictionary `d`, and if the chunk was marked for tangling, also to the
global list `tangles`.  (Actually neither `d` nor `tangles` are strictly
global, but rather are declared in the `main` function.)

```c
// ~='extract chunk'
/* s points to the character after ATSIGN/CTRL on entry */
char * final_newline_candidate;
int tangle = *s == '#'; /* 'ATSIGN#' means tangle */
int append = *s++ == '+'; /* 'ATSIGN+' means append */
char terminus = *s++; /* chunk name should be 'wrapped' in "matching" *characters* */
char * name = extract_name(s, terminus);

int new_chunk = 1;
code_chunk * c = dict_get(d, name);
if (append)
{
    if (c == NULL) c = code_chunk_new(name);
    else new_chunk = 0; /* should probably free name here */
}
else 
{
    if (c != NULL) 
        fprintf(stderr, 
            "warning, redefinition of chunk %s on line %d\n", 
            name, line_number);
    c = code_chunk_new(name);
}
c->tangle = tangle;

while (*s++ != '\n') /* scan `s` to one past the end of line */
{
    exit_fail_if(*s == '\0', 
            "Error: file ended before beginning the definition of chunk '%s'\n",
            c->name);
}
++line_number;

/* s points to the first character of the chunk definition */
list_append(&(c->contents), (void *)s);
final_newline_candidate = s;
while(1)
{
    if (*s == '\n')
    {
        ++line_number;
        final_newline_candidate = s;
    }
    else if (*s == ATSIGN) 
    {
        ~{keep track of changing ATSIGNs}
        ++s;
        if (*s == ATSIGN) {} /* escape, skip over the second ATSIGN */
                             /* so it won't be turned into a CTRL*/
        else if (*s == '\n' || *s == '\0')
        {
            /* end and record chunk */
            *final_newline_candidate = '\0'; /* yes, it was the final newline */
                                             /* null terminate the contents */
            if (new_chunk) dict_add(d, c);
            if (c->tangle) list_append(&tangles, (void *)c);
            break;
        }
    }
    else exit_fail_if ((*s == '\0'),
                "Error: file ended during definition of chunk '%s'\n",
                c->name);
    ++s;
}
// ~
```

## Code Tangling and Output

Each code chunk recorded in the list of chunks to tangle is output to a file
named the same as the code chunk:

```c
// ~='output tangle chunks recursively'
for(; tangles != NULL; tangles = tangles->successor)
{
    FILE * f;
    code_chunk * c = tangles->data;
    f = fopen(c->name, "w");
    if (f == NULL)
    {
        fprintf(stderr,
                "Warning: failed to open file '%s', skipping tangle '%s'\n",
                c->name, c->name);
        continue;
    }
    code_chunk_print(f, d, c, "");
    fclose(f);
}
// ~
```

Outputting tangle chunks is done mainly by `code_chunk_print`, which calls
itself recursively. This function proceeds character by character. Most
characters are simply echoed to the output file.  Code invocations and escape
sequences are handled specially. When a newline is encountered, this also
causes indentation to be printed. The start of each line is also noted to
facilitate keeping track of indentation when recursively expanding chunks.

```c
// ~='code chunk print'
void code_chunk_print(FILE * f, dict * d, code_chunk * c, char * indent)
{
    list * l;
    for (l = c->contents; l != NULL; l = l->successor)
    {
        char * s = l->data;
        char * start_of_line = s;
        while (*s != '\0')
        {
            if (*s == CTRL)
            {
                ++s;
                if (*s != '{') fputc(*s, f); /* escaped ATSIGN, print it */
                else /* this must be a code invocation */
                {
                    char * name = extract_name(++s, '}');
                    code_chunk * next_c = dict_get(d, name);

                    if (next_c == NULL)
                    {
                        fprintf(stderr,
                                "Warning: '%s' could not be found in invocation within `%s`\n",
                                name, c->name);
                    }
                    else 
                    {
                        ~{build the next indent}
                
                        code_chunk_print(f, d, next_c, next_indent);
                    }
                    while(*s != '}') ++s; /* scan s to the '}' */
                    /* we don't need to exit_fail_if we find the end of file during
                     * this loop, because extract_name would have already found
                     * this error */
                    
                    /* fall through to the outer ++s so s points after the '}' */

                    /* we should probably free name here */
                }
            }
            else 
            {
                fputc(*s, f);
                if (*s == '\n') 
                {
                    /* we can assume there is always another line after a '\n'
                     * because on the final line the '\n' will have been turned
                     * into a '\0' to terminate the string */
                    start_of_line = s + 1;
                    fprintf(f, "%s", indent); /* print indent on the new line */
                }
            }
            ++s;
        }
        /* if there are more contents to append, separate them with a newline */
        if (l->successor != NULL) fputc('\n', f); 
    }
}
// ~
```

We keep track of indentation so that when a chunk is invoked with leading
space, every line of the expanded chunk is printed with the same amount of
space.  This is necessary in case white space is syntactic as in e.g. python,
and is nice even when white space isn't syntactic just to preserve the
visual structure of the code in the output.

```c
// ~='build the next indent'
char * next_indent;
char tmp;
char * indent_end = start_of_line; 
while (isspace(*indent_end)) ++indent_end;
tmp = *indent_end;
*indent_end = '\0'; /* temporarily terminate line at first non-space char */
next_indent = malloc(strlen(start_of_line) + strlen(indent) + 1);
strcpy(next_indent, indent); /* copy current indent to next_indent */
strcat(next_indent, start_of_line); /* append space from current line to next_indent */
*indent_end = tmp; /* restore first non-space char */
// ~
```

## Extra Details

Read on if you are interested in further details, such as the definition of the
list and dict datatypes, the helper functions, and other minutiae.

```c
// ~='data types'
typedef struct List
{
    void * data;
    struct List * successor;
} list;

/* a list must be initialized with data */
list * list_new(void * d)
{
    list * l = malloc(sizeof(list));
    l->data = d;
    l->successor = NULL;
    return l;
}

/* we need a double pointer so that if we are passed lst == NULL we mutate *lst
 * so that it points to a new list. This happens in dict_add if the new chunk
 * is hashed into a bucket not already containing a pointer to a list */
void list_append(list ** lst, void * addend)
{
    list * a = list_new(addend);
    if (*lst == NULL)
    {
        *lst = a;
    }
    else
    {
        list * l = *lst;
        while (l->successor != NULL) l = l->successor; /* go to the end of l */
        l->successor = a;
    }
}

~{code chunk struct}

/* http://www.cse.yorku.ca/~~oz/hash.html */
unsigned long hash(unsigned char *str)
{
    unsigned long hash = 5381;
    int c;

    while ((c = *str++)) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */

    return hash;
}

typedef struct Dict
{
    list ** array;
    size_t size;
} dict;

dict * dict_new(size_t size)
{
    dict * d = malloc(sizeof(dict));
    d->array = malloc(size * sizeof(list));
    memset(d->array, (size_t)NULL, size * sizeof(list));
    d->size = size;
    return d;
}

void dict_add(dict * d, code_chunk * c)
{
    unsigned long h = hash((unsigned char *)c->name) % d->size;
    list_append(&(d->array[h]), (void *) c);
}

code_chunk * dict_get(dict * d, char * name)
{
    unsigned long h = hash((unsigned char *)name) % d->size;
    list * l = d->array[h];
    while (l != NULL)
    {
        code_chunk * c = l->data;
        if (strcmp(name, c->name) == 0) return c;
        else l = l->successor;
    }
    return NULL;
}
~
```

```c
// ~='functions'
void exit_fail_if(int condition, char * message, ...)
{
    if (!condition) return;
    va_list args;
    va_start(args, message);
    fprintf(stderr, message, args);
    va_end(args);
    exit(EXIT_FAILURE);
}

char * extract_name(char * s, char terminus)
{
    char * destination;
    char * selection_start = s;
    char * selection_end;

    while(1)
    {
        if (*s == terminus)
        {
            selection_end = s;
            break;
        }
        else exit_fail_if ((*s == '\n' || *s == '\0'),
                    "Error: unterminated name on line %d\n",
                    line_number);
        ++s;
    }

    exit_fail_if ((selection_end == selection_start),
                "Error: empty name on line %d\n",
                line_number);

    *selection_end = '\0';
    destination = malloc(strlen(selection_start) + 1);
    strcpy(destination, selection_start);
    *selection_end = terminus;
    return destination;
}

~{code chunk print}
// ~
```

```c
// ~='definitions'
~{includes}

~{globals}

~{data types}

~{functions}

~{help text}
// ~
```

```c
// ~='setup'
~{variables}

~{parse command line arguments}

~{load file into `char * source`}

~{allocate additional memory}
// ~
```

```c
// ~='includes'
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>
// ~
```

```c
// ~='parse command line arguments'
if (argc < 2 || *argv[1] == '-' /* assume -h */) 
{
    fprintf(stderr, help, VERSION, argv[0]);
    exit(EXIT_SUCCESS);
}
char * filename = argv[1];
// ~
```

Since the control sequence leader character can be changed with 'ATSIGN:',
it's necessary to swap all the ATSIGNs that are found while extracting to
some stable character to prevent bugs when tangling and weaving. It is
assumed that ascii 7 (^G, BEL) will never occur in any source code file,
so we can transliterate ATSIGNs to 7 without having to worry about escapes.
If anyone ever tries to run `lilit` on a file with actual ascii 7 embedded in
the text, it will undoubtedly cause errors. If this ever happens, the
solution would be to detect actual ascii 7 while extracting and embed some
kind of escape sequence.

```c
// ~='variables'
int file_size;
char * source;
dict * d;
list * tangles = NULL;
// ~
```

```c
// ~='load file into `char * source`'
{
    FILE * source_file = fopen(filename, "r");
    exit_fail_if ((source_file == NULL), 
            "Error: could not open file %s\n", 
            filename);
    
    /* get file size */
    fseek(source_file, 0L, SEEK_END);
    file_size = ftell(source_file);
    rewind(source_file);
    
    /* copy file into memory */
    source = malloc(1 + file_size); /* one added for null termination */
    fread(source, 1, file_size, source_file); 
    fclose(source_file);
    
    source[file_size] = 0;
}
// ~
```

```c
// ~='allocate additional memory'
d = dict_new(128); /* for storing chunks */
// ~
```

# tests

The main test case for `lilit` is its own literate source (i.e. this document).
Producing `lilit.c` by tangling `lilit.lilit` exercises all of the control
sequences specified in the help text. `lilit` should produce a source file when
run, and the same resulting source file every time it is run. This result
should be the same regardless of which version of lilit is run. These assertions
are tested in the Makefile included in this repository. Simple run `make test`
to ensure `lilit` is working as expected.
