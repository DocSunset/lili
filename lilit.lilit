<!--- @:~ --->
# lilit: the little literate programming tool

`lilit` is a simple command line program written in portable dependency-free C
that aims to provide the absolute bare minimum of functionality needed to
enable writing programs in a literate programming style.  All `lilit` does is
scan a plain-text file for a handful of control sequences, extract source code
delimited by those control sequences, and output source code files by
recursively expanding the chunks of code thus found. This is clear from the
high level structure of `lilit`'s source code:

```c
// ~#'lilit.c'
~{definitions}

int main(int argc, char ** argv)
{
    ~{setup}
    ~{extract code chunks}
    ~{output tangle chunks recursively}
    return 0;
}
// end lilit.c ~/ ~
```

This minimalist approach ensures users of `lilit` can depend on it to continue
working reliably and easily modify the source code to tailor the program to
their specific needs, such as adding support for a particular typesetting
markup.

# what is literate programming?

>Literate programming is a very simple idea: Write a book. And oh, by the
>way, the book has the actual executable source code in it.

>Timothy Daly, 2013. "[Literate Programming in the Large](https://youtu.be/Av0PQDVTP4A)"

Literate programming (first described by [Donald Knuth in his paper introducing
the idea](http://www.literateprogramming.com/knuthweb.pdf)) is a style of
computer programming that prioritizes the relationship between the program
writer and program reader.  The essence of this approach is the position that
computer programs should be written primarily as a form of communication
between humans and only incidentally as a means of instructing computing
machines to perform useful jobs.  

Few would disagree that excellent computer code, in addition to whatever other
positive qualities it may possess, should be easy for any programmer to read
and understand.  Conventionally, this ideal is approached by carefully choosing
variable and class names, breaking up complex subroutines into well-named
functions, writing unit tests that demonstrate how a given subroutine is used,
and so on;  basically, the code itself is written to be self-describing.  After
all, the source code has the final word on what the program does and how it
does it.  Comments, documentation, and any other things besides are all
irreconcilably seperate from the actual logic of the program that the code
describes, and they even run the risk of misleading the reader of a program. As
Robert Martin wrote, "[the proper use of comments is to compensate for our
failure to express ourself in
code.](https://www.goodreads.com/book/show/3735293-clean-code)"

On the other hand, there is much that the code itself may struggle to
communicate or which may even be impossible for the code to communicate.
Programming languages are constrained by the systems they are meant to control,
by the systems that translate from source code to machine code, and so on.
These constraints in turn influence the writers of the source code, the ideas
that they can express through the language, and the ways in which they can
present those ideas.  Source code excels at expressing what the program does
and how it does it. Code often struggles when it comes to communicating why it
does what it does and why it does it in that particular way rather than taking
some other approach.  Almost every programming language provides some mechanism
for embedding natural language comments in the source code, precisely to help
programmers to express that which the code cannot.  Documentation is also
increasingly integrated in programming language tooling.  But both comments and
documentation remain subordinate to the source code. They serve to help the
reader decode the source code.  The source code itself remains supreme, and
often also remains opaque, esoteric, and difficult to understand.

Literate programming proposes to invert this relationship: rather than write a
program with some explanations embedded in it, you craft a piece of writing
with a program embedded in it.  Rather than write comments and documentation
interspersed in source code, write source code interspersed in a natural
language narrative.  Rather than write a program primarily to control the
behavior of a computer and only incidentally to be read by humans, write a
piece of prose primarily to communicate with humans and only incidentally
to be executed by a computer.  This is the theory of literate programming.  

In order to write a literate program, the expressive power of most programming
languages is insufficient.  For this reason, the practice of literate
programming usually involves the use of specialized tooling that allows for
expressing source code embedded in a piece of literature.  These tools allow
the source code to be ordered and explained using the structure that most
naturally expresses the meaning of the program, rather than the order and
structure that is most convenient to the compiler or interpreter.  This
involves, for instance, allowing code chunks to be expressed in any order.

# should I write literate programs?

Proponents of literate programming argue that the style provides numerous
benefits.  The prioritization of communication over execution allows
programmers unfamiliar with a program to understand and take ownership of it,
allowing new team members in a collaborative environment to become productive
contributors to the project more quickly.  Literate programs are
also purportedly more resilient to the passage of time and changing of hands,
as new maintainers of a program are endowed with the knowledge of not only what
and how a program works but also why and what for.  Furthermore, writing the
natural language exposition of a literate program naturally forces the writer
to not only better comprehend the program they are writing but also to write a
program that is fundamentally more comprehensible.  As Donald Knuth writes, "my
programs are not only explained better than ever before; they also are better
programs, because the new methodology encourages me to do a better job."
Literate programming also seems especially well suited to environments in which
understanding the program is as important as the program itself, such as in
academic research where a program is part of research findings.  

However, despite the purported benefits, literate programming has not seen much
mainstream adoption.  Although there have been numerous remarkable success
stories (notably [one book written in a literate programming style that won an
Academy Award](https://www.pbrt.org/)), most programmers do not program in a
literate style.  This may be explained in part by the disadvantages of literate
programming.  

As Knuth recognized in the paper introducing the style, literate programming
practice usually entails writing literate programs in a document that combines
typesetting markup, literate programming specific markup, and source code.
This introduces the opportunity for syntax errors in three different languages
in addition to normal program logic errors, with the associated increase in the
complexity of debugging a literate program. More generally, literate
programming practice introduces additional tooling that necessarily adds some
complexity to writing programs.

Programming in a literate style requires authoring and maintaining not only the
program itself but also the literary work in which the program is embedded.  As
the program changes, it is essential to ensure that the associated literature
is updated with discipline lest it drift out of sync with the actual program
logic it is meant to describe. The cost of maintaining the prose in addition to
the program can be magnified in environments where the requirements for the
program and/or its design may frequently and drastically change.  

However, the most damning challenge to the adoption of literate programming
comes not from the tooling nor the maintenance of prose, but simply from the
fact that programming is hard, writing is hard, and very few people are good at
both.  This means that programmers with aptitude for literate programming are
naturally somewhat rare.

In summary:

Pros:

- Improved readability decreases time for new programmers to integrate into collaborative environments
- Program maintenance is easier especially as old maintainers become separated from the project
- Authoring prose alongside code encourages writing higher quality programs
- Emphasis on communication is a natural fit for e.g. programs produced as part of research

Cons:

- Additional tooling imposes increased debugging and programming environment complexity
- Prose introduces additional maintenance overhead, especially when requirements change quickly
- Writing good programs is hard enough without also having to write good literature

If program requirements are reasonably well defined, if it is common for
newcomers to contribute to a project, if code maintainers are likely to change
over time, if the people involved in a project are reasonably good writers as
well as programmers, and especially if the full and varied meanings of the
source code are as important as the code itself, it may be worthwhile to
consider adopting a literate programming style.

Writing in a literate programming style may seem less useful for beginners,
hobbyists, and other amateurs, who may not have the well define program
requirements and deep understanding of the programs they are writing, and who
generally work alone and so miss out on the collaborative advantages of
literate programming.  However, the same people are very likely to benefit from
more widespread adoption of literate programming, because reading and
understanding a literate program is much easier than doing the same with
programs written in a more conventional style. This is the advantage of
literate programming most exciting to me personally. Literate programs have
great potential as educational tools. In the best case, literate programs can
elevate and empower the reader in a way conventional programs simply can't.

# how does `lilit` work?

The remainder of this document (the literate source code for `lilit`) describes
the functionality and implementation of `lilit`.

`lilit` knows nothing about the machine source code language, has no runtime
configuration or flags, and makes as few assumptions as possible about the
typesetting markup used for prose passages.  Furthermore, `lilit` provides no
functionality for weaving, i.e.  producing typesetting markup from the literate
source code. This functionality is not essential for literate programming,
which is about organization and communication rather than typesetting and
generating cross references (see [this
article](http://akkartik.name/post/literate-programming) for example).  If the
writer wishes to produce a typeset document from the source code, typesetting
markup may be written directly in the lilit-formatted document and the
typesetting system can be run directly on this document. For example, this
literate source document for `lilit` is typeset in Github-flavored Markdown.

Despite its intentional limitations, `lilit` provides enough functionality to
enable writing in a literate programming style.  Code chunks can be presented
to the reader in any order, and code chunks can be referred to by name inside
of other code chunks, allowing for high levels of abstraction in the
presentation of the program.  When outputting source code, chunks are
recursively expanded into the output source files while retaining indentation
for compatibility with white space sensitive languages such as python.

The help text explains the control sequences `lilit` searches for to extract
the machine code embedded in your natural-language document:

```c
// ~='help text'
const char * help =
"lilit: the little literate programming tool -- version %s\n\
\n\
    USAGE: %s file\n\
\n\
    lilit extracts machine source code from literate source code.\n\
\n\
All control sequences begin with a special character called ATSIGN, which is \n\
set to '@' by default. Except for escaped ATSIGNs, all control sequences consume\n\
(i.e. cause to be ignored) the remainder of the line following the end of the\n\
control sequence.\n\
\n\
ATSIGN:new control character  Redefines ATSIGN to whatever immediately follows\n\
                              the : sign. This is useful if your machine source\n\
                              language uses lots of @ signs, for example.\n\
\n\
ATSIGN='chunk name'           Begin a regular chunk declaration. The chunk name\n\
                              must be surrounded by matching single (') or\n\
                              double (\") quotes (no backticks). The chunk\n\
                              definition itself begins on the next line.\n\
\n\
ATSIGN#'chunk name'           Begin a tangle chunk declaration. This is similar\n\
                              to a regular chunk, except the name of the chunk\n\
                              is also interpreted as a file name, and the chunk\n\
                              is recursively expanded into the file with that\n\
                              name, overwriting any existing file.\n\
\n\
ATSIGN+'chunk name'           Append to a chunk. The code starting on the\n\
                              next line will be added at the end of the chunk\n\
                              named by 'chunk name'. If no such chunk exists,\n\
                              then one will be created. This is useful e.g. for\n\
                              adding #include directives to the top of a c file.\n\
\n\
ATSIGN{chunk invocation}      Invoke a chunk to be recursively expanded into any\n\
                              tangled output files.\n\
\n\
ATSIGNATSIGN                  Escape sequence. A literal ATSIGN sign with no\n\
                              special meaning to lilit that will be copied as an\n\
                              ATSIGN to any output tangled documents.\n\
\n\
ATSIGN/                       End an ongoing chunk declaration.\n\
\n";
// end help text ~/ ~
```

## Program Overview

As described in the introduction, `lilit` is implemented with three main
processing stages: setup, extraction, and output. The setup phase reads the
file to be processed into memory. During extraction, the file is scanned for
code chunk definitions, and these are logged in data structures convenient for
output. The output phase then recursively expands code chunks into files.

## Code Chunk Extraction

```c
// ~+'globals'
char ATSIGN = '@';
// ~/ ~
```

While scanning and extracting code chunks, anytime a newline character is
encountered the variable `line_number` is incremented.  `line_number` is
currently only used when printing error messages to help the user find the
location of the error.

```c
// ~+'globals'
int line_number = 1;
// ~/ ~
```

The outer-most loop of the extraction phase ignores your literate prose while
scanning for control sequences. When one is found, control passes to the inner
loop where the chunks are actually extracted.

```c
// ~='extract code chunks'
{
    char * s = source;
    while (*s != '\0')
    {
        if (*s == '\n') ++s, ++line_number;
        else if (*s++ == ATSIGN)
        {
            switch (*s)
            {
            case '#':
            case '=':
            case '+':
                ~{extract chunk definition}
                break;
            case ':':
                ~{redefine ATSIGN}
                break;
            }
        }
    }
}
// ~/ ~

// ~='redefine ATSIGN'
++s;
exit_fail_if (( *s == '=' || *s == '#' || *s == '+' || *s == '{' 
             || *s == ':' || *s == '/' || *s == '\n'), 
        "Error: cannot redefine ATSIGN to a character used in control sequences on line %d\n",
        line_number);
ATSIGN = *s;
// ~/ ~

// ~='extract chunk definition'
{
    code_chunk * chunk;
    int done = 0; 

    if (*(s + 1) != '\'' && *(s + 1) != '\"') /* not a chunk definition */ break;

    ~{prepare chunk}

    while (!done) 
    {
        char * start_of_line = s;
        while(1) /* process one line */
        {
            if (*s == '\n')
            {
                ~{extract code line}
                break;
            }
            else if (*s == ATSIGN)
            {
                ~{process control sequence inside chunk definition}
                break;
            }
            else exit_fail_if(*s == '\0', "File ended during definition of chunk %s", chunk->name);
            /* else */ ++s;
        }
    }
}
// ~/ ~

// ~='prepare chunk'
{
    char type = *s++;
    char * name = extract_name(&s);
    int tangle = type == '#';
    int append = type == '+';
    
    chunk = dict_get(d, name);
    if (chunk == NULL) /* new chunk definition */
    {
        chunk = code_chunk_new(name);
        dict_add(d, chunk);
    }
    else if (!append)
    {
        exit_fail_if(chunk->contents != NULL, 
                "Error: redefinition of chunk '%s' on line %d.\n    Maybe you meant to use a + chunk or accidentally used the same name twice.\n", 
                name, line_number);
        /* todo: free existing chunk? */
    }
    if (tangle) list_push(&tangles, (void *)chunk);
}

exit_fail_if(!advance_to_next_line(&s), 
        "Error: file ended before beginning of definition of chunk '%s' on line '%d'\n", 
        chunk->name, line_number);
// ~/ ~

// ~='process control sequence inside chunk definition'
++s;
if (*s == '{')
{
    ~{extract reference line}
}
else if (*s == ATSIGN)
{
    ~{extract line with escape sequence}
}
else if (*s == '/')
{
    done = 1; /* break out of chunk definition loop */
    advance_to_next_line(&s);
}
/* else ignore this ATSIGN and carry on */
// ~/ ~

// ~='extract line with escape sequence'
chunk_contents * beginning_part = code_contents_new(start_of_line);
chunk_contents * end_part = code_contents_new(s);
char * at_the_atsign = s - 1;

beginning_part->partial_line = 1;
list_push_back(&chunk->contents, (void *)beginning_part);
list_push_back(&chunk->contents, (void *)end_part);

exit_fail_if(!advance_to_next_line(&s), 
        "Error: file ended during definition of chunk '%s'\n    following the escape sequence on line '%d'\n", 
        chunk->name, line_number);

*at_the_atsign = '\0'; /* terminate beginning part */
*(s - 1) = '\0'; /* terminate end part; s - 1 points to a newline character */
// ~/ ~

// ~='extract code line'
chunk_contents * full_line = code_contents_new(start_of_line);
list_push_back(&chunk->contents, (void *)full_line);
*s++ = '\0';
++line_number;
// ~/ ~

// ~='extract reference line'
*(s - 1) = '\0'; /* terminate the indent string in place; s - 1 is the ATSIGN */
char * name = extract_name(&s);
code_chunk * ref = dict_get(d, name);
if (ref == NULL) /* chunk hasn't been defined yet */
{
    ref = code_chunk_new(name);
    dict_add(d, ref);
}
char * indent = start_of_line;
list_push_back(&chunk->contents, (void *)reference_contents_new(indent, ref));
exit_fail_if(!advance_to_next_line(&s), 
        "Error: file ended during definition of chunk '%s'\n    following invocation of chunk '%s' on line '%d'\n", 
        chunk->name, name, line_number);
// ~/ ~

// ~='code chunk struct'
typedef enum ContentType {code, reference} content_t;

typedef struct CodeChunk
{
    char * name;
    list * contents;
} code_chunk;

typedef struct ChunkContents
{
    char * string;
    code_chunk * reference;
    int partial_line;
} chunk_contents;

chunk_contents * code_contents_new(char * code)
{
    chunk_contents * c = malloc(sizeof(chunk_contents));
    c->string = code;
    c->reference = NULL;
    c->partial_line = 0;
    return c;
}

chunk_contents * reference_contents_new(char * indent, code_chunk * ref)
{
    chunk_contents * c = malloc(sizeof(chunk_contents));
    c->string = indent;
    c->reference = ref;
    c->partial_line = 0;
    return c;
}

content_t contents_type(chunk_contents * c)
{
    if (c->reference != NULL) return reference; 
    else return code;
}

code_chunk * code_chunk_new(char * name)
{
    code_chunk * chunk = malloc(sizeof(code_chunk));
    chunk->name     = name;
    chunk->contents = NULL;
    return chunk;
}
// ~/ ~
```

## Code Tangling and Output

Each code chunk recorded in the list of chunks to tangle is output to a file
named the same as the code chunk:

```c
// ~='output tangle chunks recursively'
for(; tangles != NULL; tangles = tangles->successor)
{
    FILE * f;
    code_chunk * c = tangles->data;
    f = fopen(c->name, "w");
    if (f == NULL)
    {
        fprintf(stderr,
                "Warning: failed to open file '%s', skipping tangle '%s'\n",
                c->name, c->name);
        continue;
    }
    code_chunk_print(f, d, c, NULL);
    fclose(f);
}
// ~/ ~
```

Outputting tangle chunks is done mainly by `code_chunk_print`, which calls
itself recursively. This function proceeds character by character. Most
characters are simply echoed to the output file.  When a newline is
encountered, this also causes indentation to be printed. 

```c
// ~='code chunk print'
void code_chunk_print(FILE * f, dict * d, code_chunk * c, list * indents)
{
    list * l;
    for (l = c->contents; l != NULL; l = l->successor)
    {
        chunk_contents * contents = l->data;
        if (contents_type(contents) == code)
        {
            if (*contents->string != '\0')
            {
                /* print indents on non-empty lines */
                list * i;
                for (i = indents; i != NULL; i = i->successor)
                {
                    fputs((char *)i->data, f);
                }
            }
            fputs(contents->string, f); 
            if (contents->partial_line == 0) fputc('\n', f);
        }
        else if (contents_type(contents) == reference)
        {
            code_chunk * next_c = contents->reference;
            list_push(&indents, (void *)contents->string);
            code_chunk_print(f, d, next_c, indents);
            list_pop(&indents);
        }
    }
}
// ~/ ~
```

## Extra Details

Read on if you are interested in further details, such as the definition of the
list and dict datatypes, the helper functions, and other minutiae.

```c
// ~='data types'
typedef struct List
{
    void * data;
    struct List * successor;
} list;

/* a list must be initialized with data */
list * list_new(void * d)
{
    list * l = malloc(sizeof(list));
    l->data = d;
    l->successor = NULL;
    return l;
}

/* we need a double pointer so that if we are passed lst == NULL we mutate *lst
 * so that it points to a new list. This happens in dict_add if the new chunk
 * is hashed into a bucket not already containing a pointer to a list */
void list_push_back(list ** lst, void * elem)
{
    list * a = list_new(elem);
    if (*lst == NULL)
    {
        *lst = a;
    }
    else
    {
        list * l = *lst;
        while (l->successor != NULL) l = l->successor; /* go to the end of l */
        l->successor = a;
    }
}

list * list_pop_back(list ** lst)
{
    if (*lst == NULL) return NULL;
    if ((*lst)->successor == NULL)
    {
        free((void *)(*lst));
        *lst = NULL;
        return NULL;
    }
    {
        list * l = (*lst)->successor;
        while (l->successor != NULL) l = l->successor;
        free((void *)l->successor);
        l->successor = NULL;
        return l;
    }
}

void list_push(list ** lst, void * elem)
{
    list * p = list_new(elem);
    if (*lst == NULL)
    {
        *lst = p;
    }
    else
    {
        list * l = *lst;
        *lst = p;
        p->successor = l;
    }
}

void list_pop(list ** lst)
{
    list * p = *lst;
    if (p == NULL) return;
    list * l = p->successor;
    *lst = l;
    free((void *)p);
}

~{code chunk struct}

/* http://www.cse.yorku.ca/~~oz/hash.html */
unsigned long hash(unsigned char *str)
{
    unsigned long hash = 5381;
    int c;

    while ((c = *str++)) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */

    return hash;
}

typedef struct Dict
{
    list ** array;
    size_t size;
} dict;

dict * dict_new(size_t size)
{
    dict * d = malloc(sizeof(dict));
    d->array = malloc(size * sizeof(list));
    memset(d->array, (size_t)NULL, size * sizeof(list));
    d->size = size;
    return d;
}

void dict_add(dict * d, code_chunk * c)
{
    unsigned long h = hash((unsigned char *)c->name) % d->size;
    list_push_back(&(d->array[h]), (void *) c);
}

code_chunk * dict_get(dict * d, char * name)
{
    unsigned long h = hash((unsigned char *)name) % d->size;
    list * l = d->array[h];
    while (l != NULL)
    {
        code_chunk * c = l->data;
        if (strcmp(name, c->name) == 0) return c;
        else l = l->successor;
    }
    return NULL;
}
~/ ~
```

```c
// ~='functions'
void exit_fail_if(int condition, char * message, ...)
{
    if (!condition) return;
    va_list args;
    va_start(args, message);
    vfprintf(stderr, message, args);
    va_end(args);
    exit(EXIT_FAILURE);
}

char * extract_name(char ** source)
{
    char * s = *source;
    char terminus = *s++;
    if (terminus == '{') terminus = '}';
    char * destination = s;

    for (; *s != terminus; ++s)
        exit_fail_if ((*s == '\n' || *s == '\0'), 
                "Error: unterminated name on line %d\n", line_number);
    exit_fail_if (destination == s,
                "Error: empty name on line %d\n",
                line_number);

    *s = '\0';
    *source = s + 1;
    return destination;
}

int advance_to_next_line(char ** source)
{
    char * s = *source;
    while (*s != '\n') if (*s++ == '\0') return 0;
    *source = s + 1;
    ++line_number;
    return 1;
}

~{code chunk print}
// ~/ ~
```

```c
// ~='definitions'
~{includes}

~{globals}

~{data types}

~{functions}

~{help text}
// ~/ ~
```

```c
// ~='setup'
~{variables}

~{parse command line arguments}

~{load file into `char * source`}

~{allocate additional memory}
// ~/ ~
```

```c
// ~='includes'
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>
// ~/ ~
```

```c
// ~='parse command line arguments'
if (argc < 2 || *argv[1] == '-' /* assume -h */) 
{
    fprintf(stderr, help, VERSION, argv[0]);
    exit(EXIT_SUCCESS);
}
char * filename = argv[1];
// ~/ ~
```

Since the control sequence leader character can be changed with 'ATSIGN:',
it's necessary to swap all the ATSIGNs that are found while extracting to
some stable character to prevent bugs when tangling and weaving. It is
assumed that ascii 7 (^G, BEL) will never occur in any source code file,
so we can transliterate ATSIGNs to 7 without having to worry about escapes.
If anyone ever tries to run `lilit` on a file with actual ascii 7 embedded in
the text, it will undoubtedly cause errors. If this ever happens, the
solution would be to detect actual ascii 7 while extracting and embed some
kind of escape sequence.

```c
// ~='variables'
int file_size;
char * source;
dict * d;
list * tangles = NULL;
// ~/ ~
```

```c
// ~='load file into `char * source`'
{
    FILE * source_file = fopen(filename, "r");
    exit_fail_if ((source_file == NULL), 
            "Error: could not open file %s\n", 
            filename);
    
    /* get file size */
    fseek(source_file, 0L, SEEK_END);
    file_size = ftell(source_file);
    rewind(source_file);
    
    /* copy file into memory */
    source = malloc(1 + file_size); /* one added for null termination */
    fread(source, 1, file_size, source_file); 
    fclose(source_file);
    
    source[file_size] = 0;
}
// ~/ ~
```

```c
// ~='allocate additional memory'
d = dict_new(128); /* for storing chunks */
// ~/ ~
```

# tests

The main test case for `lilit` is its own literate source (i.e. this document).
Producing `lilit.c` by tangling `lilit.lilit` exercises all of the control
sequences specified in the help text. `lilit` should produce a source file when
run, and the same resulting source file every time it is run. This result
should be the same regardless of which version of lilit is run. These assertions
are tested in the Makefile included in this repository. Simple run `make test`
to ensure `lilit` is working as expected.
