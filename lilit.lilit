# lilit: the little literate program tangler

Inspired by the many formidable "\*web" literate programming tools, `lilit`
aims to provide the absolute bare minimum of functionality needed to enable
writing programs in a literate programming style.  Specifically, `lilit` will
parse literate source code marked up with simple control sequences in order to
extract embedded machine source code (i.e. `lilit` will "tangle" machine source
code from literate source code).  `lilit` knows nothing about the machine
source code language, has no runtime configuration or flags, and makes as few
assumptions as possible about the typesetting markup used for prose passages.
Furthermore, `lilit` provides no functionality for weaving, i.e. producing
typesetting markup from the literate source code. This functionality is not
essential for literate programming, which is about organization and
communication rather than typesetting and generating cross references (see
[this article](http://akkartik.name/post/literate-programming) for example).  

```c
@:~
~='markup help text'
const char * help =
"Control sequences: \n\
\n\
Control sequences are permitted to appear at any point in the source file, \n\
except for flags which must appear inside of a code chunk. All control sequences\n\
begin with a special character called ATSIGN, which is set to '@' by default.\n\
\n\
\n\
ATSIGN:new control character  Redefines ATSIGN to whatever immediately follows\n\
                              the : sign. This is useful if your machine source\n\
                              has lots of @ signs, for example.\n\
\n\
ATSIGN='chunk name'           Begin a regular chunk declaration.\n\
\n\
ATSIGN#'chunk name'           Begin a tangle chunk declaration. This is similar\n\
                              to a regular chunk, except the name of the chunk\n\
                              is also interpreted as a file name, and the chunk\n\
                              is recursively expanded into the file with that\n\
                              name, overwriting any existing file.\n\
\n\
ATSIGN                        End a chunk declaration. The ATSIGN must be \n\
                              immediately followed by a newline character or the\n\
                              end of the file without intervening white space.\n\
\n\
ATSIGN{chunk invocation}      Invoke a chunk to be recursively expanded into any\n\
                              tangled output files.\n\
\n\
ATSIGNATSIGN                  Escape sequence. A literal ATSIGN sign with no\n\
                              special meaning to lilit that will be copied as an\n\
                              ATSIGN to any output tangled documents.\n\
";
~
```

## Program Overview

The remainder of this document (which is the literate source code for `lilit`)
describes the implementation of this tool.  

The program takes two passes over the data: extraction and output.

```c
~#'lilit.c'
~{definitions}

int main(int argc, char ** argv)
{
    ~{setup}
    ~{extract code chunks}
    ~{output tangle chunks recursively}
}
~
```

## Code Chunk Extraction

Extraction proceeds mostly character by character, breaking out into inner
subroutines when an ATSIGN is encountered.

While extracting code chunks, anytime a newline character is encountered the
global variable `line_number` is incremented. `line_number` is currently only
used when printing error messages to help the user find the location of the
error.

```c
~='extract code chunks'
{
    char * s = source;
    
    while (*s != '\0') 
    {
        if (*s == '\n')
        {
            ++line_number;
        }
        else if (*s == ATSIGN)
        {
            ~{keep track of changing ATSIGNs}
            ++s;

            if (*s == '=' || *s == '#')
            {
                ~{extract chunk}
            }
            else if (*s++ == ':')
            {
                ~{change ATSIGN}
            }
        }
        ++s;
    }
}
~
```

Changing the `ATSIGN` character is straightforward to understand, so here it is
in full.

```c
~='change ATSIGN'
if  (  *s == ':' 
    || *s == '=' 
    || *s == '#' 
    || *s == '\n' 
    || *s == '{' 
    )
{
    fprintf(stderr,
            "Error: cannot redefine ATSIGN to a character used in control sequences on line %d\n",
            line_number);
    exit(1);
}
else ATSIGN = *s;
~
```

Although changing ATSIGN is simple, allowing ATSIGN to be dynamically changed
does introduce a bit of complexity.  Code chunk invocations are rediscovered
when outputting tangles.  Suppose that ATSIGN is changed at the beginning of
the file to '!'.  All of the code invocations in the first half of the document
use ATSIGN = '!'.  Then ATSIGN is redefined to '&', and the code chunks in the
latter half of the program use '&'. When its time to output the tangle, the
variable ATSIGN will still be equal to '&', so if the output subroutine is
looking for ATSIGN it will miss all of the code invocations from the first half
of the file, which were invoked with a '!'.

To resolve this issue, ATSIGNs are converted to CTRL so that we can find them
again later even in case ATSIGN is changed to some other character in the
interim. CTRL is chosen to be a character unlikely to appear in any source
code.

```c
~='keep track of changing ATSIGNs'
*s = CTRL; /* set ATSIGN to CTRL and increment s */
~
```

The inner chunk extraction subroutine works similarly to the outer one, but
does the actual work of extracting a single chunk and recording it for easy
access when outputting tangles.

For reference, here is the chunk data structure:

```c
~='code chunk struct'
typedef struct CodeChunk
{
    char * name;
    list * contents;
    int tangle;
} code_chunk;

/* every code chunk must have a name */
code_chunk * code_chunk_new(char * name)
{
    code_chunk * chunk = malloc(sizeof(code_chunk));
    chunk->name     = name;
    chunk->contents = NULL;
    chunk->tangle   = 0;
    return chunk;
}
~
```

Extracting the chunk means filling the contents list with null-terminated lines
of code. Rather than duplicating each line into newly allocated strings, the
lines are instead null-terminated in place by editing the source buffer via
`*s`. So each link in the list is initialized by copying `s` when it points to
the beginning of the line, and later the line will be terminated when a newline
character is found.

When the terminating `ATSIGN` is found, the chunk is added to the global chunk
dictionary `d`, and if the chunk was marked for tangling, also to the global
list `tangles`. (Actually neither `d` nor `tangles` are strictly global, but
rather are declared in the `main` function.)

```c
~='extract chunk'
/* s points to the character after ATSIGN/CTRL on entry */
int tangle = *s++ == '#'; /* 'ATSIGN#' means tangle */
char terminus = *s++; /* chunk name should be 'wrapped' in "matching" *characters* */
code_chunk * c = code_chunk_new(extract_name(s, terminus, 1));
c->tangle = tangle;

while (*s++ != '\n') {} /* scan `s` to one past the end of line */
char * start_of_line = s;

for (; *s; ++s)
{
    if (*s == ATSIGN) 
    {
        ~{keep track of changing ATSIGNs}
        ++s;
        if (*s == ATSIGN) ++s; /* escape, skip over the second ATSIGN */
                               /* so it won't be turned into a CTRL*/
        else if (*s == '\n' || *s == '\0')
        {
            /* end and record chunk */
            if (*(s - 2) != '\0')
            /* if the ATSIGN was on a line with other content */
            {
                /* set the ATSIGN/CTRL to null 
                 * this terminates the final line if the ATSIGN was on it */
                *(s - 1) = '\0'; 
                list_append(&c->contents, (void *)(start_of_line)); /* append current line to list */
            }
            dict_add(d, c);
            if (c->tangle) list_append(&tangles, (void *)c);
            break;
        }
    }
    else if (*s == '\n')
    {
        ++line_number;
        *s = '\0'; /* end the current line */
        list_append(&c->contents, (void *)(start_of_line)); /* append current line to list */
        start_of_line = s + 1;
    }
}
~
```

## Code Tangling and Output

Each code chunk recorded in the list of chunks to tangle is output to a file
named the same as the code chunk:

```c
~='output tangle chunks recursively'
for(; tangles != NULL; tangles = tangles->successor)
{
    FILE * f;
    code_chunk * c = tangles->data;
    f = fopen(c->name, "w");
    if (f == NULL)
    {
        fprintf(stderr,
                "Warning: failed to open file '%s', skipping tangle '%s'\n",
                c->name, c->name);
        continue;
    }
    code_chunk_print(f, d, c, "", 0);
    fclose(f);
}
~
```

Outputting tangle chunks is done mainly by `code_chunk_print`, which calls
itself recursively. The bulk of this function is spent handling the expansion
of code chunks invoked within the current code chunk, as well as dealing with
escape sequences. With this expansion handling abstracted away, it's clearer
that the function simply iterates over the lines of content in the chunk,
printing them one at a time with a newline added.

```c
~='code chunk print'
void code_chunk_print(FILE * f, dict * d, code_chunk * c, char * indent, int indented)
{
    list * l = c->contents;
    /* https://stackoverflow.com/questions/17983005/c-how-to-read-a-string-line-by-line */
    for (; l != NULL; l = l->successor)
    {
        char * control;
        char * s = l->data;
        if (!indented) fprintf(f, "%s", indent);
        if ((control = strchr(s, CTRL)) != NULL) 
        {
            ~{handle code invocations and escape sequences}
        }
        else fprintf(f, "%s\n", s); /* print a whole line with no control */
        indented = 0;
    }
}
~
```

A control character can appear anywhere on the line, and may reflect an escape
sequence or a code invocation. We need to print whatever is on the line before
the control character, ensure that escaped characters are printed normally 
without the control character escaping them, expand any code invocations, and
ensure that any code after an invocation is also printed normally.

Furthermore, when expanding code chunks we need to ensure that the level of
indentation is propogated to each line of the expanded chunk, otherwise the
code would be malformed in languages where indentation is syntactic such as
python.

```c
~='handle code invocations and escape sequences'
while ((control = strchr(s, CTRL)) != NULL)
/* while there are invocations on this line */
{
    ~{print whatever is before the control}
    ~{handle escape sequences}

    /* at this point we know the control character must indicate a code invocation */
    ~{expand the code invocation}

    s = strchr(s, '}') + 1; /* advance s to point after the invocation */
}
if (strlen(s) != 0) fprintf(f, "%s\n", s); /* print remainder of line */
~
```

Printing the lead up to the control character is done by temporarily
null-terminating the string at the position of the control character.

```c
~='print whatever is before the control'
*control = '\0';
fprintf(f, "%s", s);
*control = CTRL;
~
```

If an escape sequence is detected, the string pointer is shifted up to point at
the escaped character, and the loop is continued. If there are any more control
characters on the line, the escaped character will be printed along with any
other code that preceeds the next control character when the loop passes over
~{print whatever is before the control} again. Otherwise, if there are no more
control characters, program flow will break out of the loop and the escaped
character will be printed along with anything else on the line trailing the
escape-control.

```c
~='handle escape sequences'
if (*(control + 1) != '{')
{
    s = control + 1;
    continue;
}
~
```

If the control character is not part of an escape sequence, it must be part of 
a code invocation. 
Finally, the chunk is looked up in the chunk dictionary, and the print function
is called recursively to expand it. Notably, because the indentation on the 
current line was already printed during ~{print whatever is before the control},
the `indented` flag is initialized to `true` so that the indentation won't be
printed a second time when expanding the first line of `next_c`.

```c
~='expand the code invocation'
{
    char * name = extract_name(strchr(control, '{') + 1, '}', 0);
    code_chunk * next_c = dict_get(d, name);
    if (next_c == NULL)
    {
        fprintf(stderr,
                "Warning: invocation of chunk '%s' could not be found\n",
                name);
    }
    else 
    {
        ~{build the next indent}

        code_chunk_print(f, d, next_c, next_indent, 1);
    }
}
~
```

Before expanding the chunk, the current level of indentation
is determined by concatenating any indentation on the current line with
indentation passed in by the caller.

```c
~='build the next indent'
char * next_indent;
char tmp;
char * indent_end = s; 
while (isspace(*indent_end)) ++indent_end;
tmp = *indent_end;
*indent_end = '\0';
next_indent = malloc(strlen(s) + strlen(indent) + 1);
strcpy(next_indent, s); 
strcat(next_indent, indent);
*indent_end = tmp;
~
```

## Details

This function is used both to get the name of chunk when extracting chunks, and
to get the name of an invocation when outputting tangled code. `s` points to the
first character of the name, and terminus is the character expected to mark
the end of the name (e.g. '}' in the case of code invocations)

```c
~='extract name'
char * extract_name(char * s, char terminus, int on_line)
{
    char * destination;
    char * selection_start = s;
    char * selection_end = strchr(selection_start, terminus);

    if ((on_line && selection_end > strchr(selection_start, '\n')) || selection_end == NULL)
    {
        fprintf(stderr,
                "Error: unterminated name on line %d\n",
                line_number);
        exit(1);
    }
    if (selection_end - selection_start == 0) 
    {
        fprintf(stderr,
                "Error: empty name on line %d\n",
                line_number);
        exit(1);
    }
    *selection_end = '\0';
    destination = malloc(strlen(selection_start) + 1);
    strcpy(destination, selection_start);
    *selection_end = terminus;
    return destination;
}
~
```

```c
~='definitions'
~{includes}

~{globals}

~{data types}

~{functions}

~{markup help text}
~
```

```c
~='setup'
~{variables}

~{parse command line arguments}

~{load file into `char * source`}

~{allocate additional memory}
~
```

```c
~='includes'
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
~
```

```c
~='data types'
typedef struct List list;

~{code chunk struct}

struct List
{
    void * data;
    struct List * successor;
};

/* a list must be initialized with data */
list * list_new(void * d)
{
    list * l = malloc(sizeof(list));
    l->data = d;
    l->successor = NULL;
}

void list_append(list ** lst, void * addend)
{
    list * a = list_new(addend);
    if (*lst == NULL)
    {
        *lst = a;
    }
    else
    {
        list * l = *lst;
        while (l->successor != NULL) l = l->successor; /* go to the end of l */
        l->successor = a;
    }
}

/* http://www.cse.yorku.ca/~~oz/hash.html */
unsigned long hash(unsigned char *str)
{
    unsigned long hash = 5381;
    int c;

    while (c = *str++) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */

    return hash;
}

typedef struct Dict
{
    list ** array;
    size_t size;
} dict;

dict * dict_new(size_t size)
{
    dict * d = malloc(sizeof(dict));
    d->array = malloc(size * sizeof(list));
    memset(d->array, (size_t)NULL, size * sizeof(list));
    d->size = size;
}

void dict_add(dict * d, code_chunk * c)
{
    unsigned long h = hash(c->name) % d->size;
    list_append(&(d->array[h]), (void *) c);
}

code_chunk * dict_get(dict * d, char * name)
{
    unsigned long h = hash(name) % d->size;
    list * l = d->array[h];
    while (l != NULL)
    {
        code_chunk * c = l->data;
        if (strcmp(name, c->name) == 0) return c;
        else l = l->successor;
    }
    return NULL;
}
~
```

```c
~='parse command line arguments'
if (argc < 2 || *argv[1] == '-' /* assume -h */) 
{
    printf("%s", help);
    exit(0);
}
char * filename = argv[1];
~
```

```c
~='functions'
~{extract name}

~{code chunk print}
~
```

Since the control sequence leader character can be changed with 'ATSIGN:',
it's necessary to swap all the ATSIGNs that are found while extracting to
some stable character to prevent bugs when tangling and weaving. It is
assumed that ascii 7 (^G, BEL) will never occur in any source code file,
so we can transliterate ATSIGNs to 7 without having to worry about escapes.
If anyone ever tries to run `lilit` on a file with actual ascii 7 embedded in
the text, it will undoubtedly cause errors. If this ever happens, the
solution would be to detect actual ascii 7 while extracting and embed some
kind of escape sequence.

```c
~='globals'
char ATSIGN = 64; /* ascii for at sign */
const char CTRL = 7; /* ascii ^G, aka BEL */
int line_number = 0;
~
```

```c
~='variables'
int file_size;
char * source;
dict * d;
list * tangles = NULL;
~
```

```c
~='load file into `char * source`'
{
    FILE * source_file = fopen(filename, "r");
    if (source_file == NULL)
    {
        fprintf(stderr, "Error: could not open file %s\n", filename);
        exit(1);
    }
    
    /* get file size */
    fseek(source_file, 0L, SEEK_END);
    file_size = ftell(source_file);
    rewind(source_file);
    
    /* copy file into memory */
    source = malloc(1 + file_size); /* one added for null termination */
    fread(source, 1, file_size, source_file); 
    fclose(source_file);
    
    source[file_size] = 0;
}
~
```

```c
~='allocate additional memory'
d = dict_new(128); /* for storing chunks */
~
```
