# lilit: the little literate program tangler

Inspired by the many formidable "*web" literate programming tools, `lilit` aims
to provide the absolute bare minimum of functionality needed to enable writing
programs in a literate programming style.  Specifically, `lilit` will parse
literate source code marked up with simple control sequences in order to
extract embedded machine source code (i.e. `lilit` will "tangle" machine source
code from literate source code).  `lilit` knows nothing about the machine
source code language, has no runtime configuration, and makes as few
assumptions as possible about the typesetting markup used for prose passages.
Furthermore, `lilit` provides no functionality for weaving, i.e. producing
typesetting markup from the literate source code. This functionality is not
essential for literate programming, which is about organization and
communication rather than typesetting and generating cross references (see for
example http://akkartik.name/post/literate-programming).  

@:~

~=markup help text
const char * help =
"Control sequences: \n\
\n\
Control sequences are permitted to appear at any point in the source file, \n\
except for flags which must appear inside of a code chunk. All control sequences\n\
begin with a special character called ATSIGN, which is set to '@' by default.\n\
\n\
\n\
ATSIGN:new control character  Redefines ATSIGN to whatever immediately follows\n\
                              the : sign. This is useful if your machine source\n\
                              has lots of @ signs, for example.\n\
\n\
ATSIGN='chunk name'           Begin a regular chunk declaration.\n\
\n\
ATSIGN#'chunk name'           Begin a tangle chunk declaration. This is similar\n\
                              to a regular chunk, except the name of the chunk\n\
                              is also interpreted as a file name, and the chunk\n\
                              is recursively expanded into the file with that\n\
                              name, overwriting any existing file.\n\
\n\
ATSIGN                        End a chunk declaration. The ATSIGN must be \n\
                              immediately followed by a newline character or the\n\
                              end of the file without intervening white space.\n\
\n\
ATSIGN{chunk invocation}      Invoke a chunk to be recursively expanded into any\n\
                              tangled output files.\n\
\n\
ATSIGNATSIGN                  Escape sequence. A literal ATSIGN sign with no\n\
                              special meaning to lilit that will be copied as an\n\
                              ATSIGN to any output tangled or woven documents.\n\
\n\
";
~

The program takes two passes over the data: extraction and output.

~#lilit.c
~{definitions}

int main(int argc, char ** argv)
{
    ~{setup}
    ~{extract code chunks}
    ~{output tangle chunks recursively}
}
~

# Extraction

~=extract code chunks
{
    char * s = source;
    
    while (*s != '\0') 
    {
        if (*s == '\n')
        {
            ++line_number;
        }
        else if (*s == ATSIGN)
        {
            /* ATSIGNs are converted to CTRL so that we can find them again
             * later even in case ATSIGN is changed to some other character
             * in the interim */
            *s++ = CTRL; /* set ATSIGN to CTRL and increment s */

            if (*s == '=' || *s == '#')
            {
                ~{extract chunk}
            }
            else if (*s++ == ':')
            {
                ~{change ATSIGN}
            }
        }
        ++s;
    }
}
~

The chunk name is expected to occupy the remainder of a line, which is copied
to the respective field of the `current_chunk` by calling this function:

~=duplicate line
char * duplicate_line_and_increment(char ** s)
{
    char * selection_start = *s;
    char * destination;
    char * selection_end;

    while (isspace(*selection_start)) ++selection_start; 
    selection_end = strchr(selection_start, '\n');
    while (isspace(*selection_end)) --selection_end; 
    ++selection_end; /* point one past the last non-whitespace character */

    if (selection_end - selection_start == 0) return NULL;

    *selection_end = '\0';
    destination = malloc(strlen(selection_start) + 1);
    strcpy(destination, selection_start);
    *selection_end = '\n';

    *s = selection_end + 1; /* s points after newline */
    line_number += 1;

    return destination;
}
~

~=extract invocation name
char * extract_invocation_name(char * s)
{
    char * selection_start = s;
    char * destination;
    char * selection_end = strchr(selection_start, '}');
    if (selection_end == NULL)
    {
        fprintf(stderr,
                "Error: unterminated chunk invocation on line %d\n",
                line_number);
        exit(1);
    }
    if (selection_end - selection_start == 0) 
    {
        fprintf(stderr,
                "Error: empty chunk invocation on line %d\n",
                line_number);
        exit(1);
    }
    *selection_end = '\0';
    destination = malloc(strlen(selection_start) + 1);
    strcpy(destination, selection_start);
    *selection_end = '}';
    return destination;
}
~

~=change ATSIGN
if  (  *s == ':' 
    || *s == '=' 
    || *s == '#' 
    || *s == '\n' 
    || *s == '{' 
    )
{
    fprintf(stderr,
            "Error: cannot redefine ATSIGN to a character used in control sequences on line %d\n",
            line_number);
    exit(1);
}
else ATSIGN = *s;
~

~=extract chunk
int tangle = *s++ == '#';
code_chunk * c = code_chunk_new(duplicate_line_and_increment(&s));
c->contents = list_new((void *)s);
c->tangle = tangle;

if (c->name == NULL)
{
    fprintf(stderr,
            "Error: expected code chunk name on line %d.\n",
            line_number);
    exit(1);
}

for (; *s; ++s)
{
    if (*s == ATSIGN) 
    {
        *s = CTRL;
        if (*(s + 1) == ATSIGN) ++s; /* escape, ignore the second ATSIGN */
    }
    else if (*s == '\n')
    {
        ++line_number;
        if (*(s - 1) == CTRL)
        {
            *(s - 1) = '\0'; 
            dict_add(d, c);
            if (c->tangle)
            {
                list_append(&tangles, (void *)c);
            }
            break;
        }
        *s++ = '\0';
        list_append(&c->contents, (void *)s);
    }
}
~

~=output tangle chunks recursively
for(; tangles != NULL; tangles = tangles->successor)
{
    FILE * f;
    code_chunk * c = tangles->data;
    f = fopen(c->name, "w");
    if (f == NULL)
    {
        fprintf(stderr,
                "Warning: failed to open file '%s', skipping tangle '%s'\n",
                c->name, c->name);
        continue;
    }
    code_chunk_print(f, d, c, "", 0);
    fclose(f);
}
~

~=code chunk print
void code_chunk_print(FILE * f, dict * d, code_chunk * c, char * indent, int indented)
{
    list * l = c->contents;
    /* https://stackoverflow.com/questions/17983005/c-how-to-read-a-string-line-by-line */
    for (; l != NULL; l = l->successor)
    {
        char * invocation;
        char * s = l->data;
        if (!indented) fprintf(f, "%s", indent);

        invocation = strchr(s, CTRL);
        while (invocation != NULL)
        {
            code_chunk * next_c;
            char tmp;
            char * name;
            char * indent_end;
            char * next_indent;

            /* print whatever is before the invocation */
            *invocation = '\0';
            fprintf(f, "%s", s);
            *invocation = CTRL;

            /* check if the CTRL character is from an escape sequence */
            if (*(invocation + 1) != '{')
            {
                s = invocation + 1;
                invocation = strchr(s, CTRL);
                continue;
            }

            /* build the next indent */
            indent_end = s; while (isspace(*indent_end)) ++indent_end;
            tmp = *indent_end;
            *indent_end = '\0';
            next_indent = malloc(strlen(s) + strlen(indent) + 1);
            strcpy(next_indent, s); 
            strcat(next_indent, indent);
            *indent_end = tmp;

            /* print the invocation itself */
            invocation = strchr(invocation, '{') + 1; 
            name = extract_invocation_name(invocation);
            next_c = dict_get(d, name);
            if (next_c == NULL)
            {
                fprintf(stderr,
                        "Warning: invocation of chunk '%s' could not be found\n",
                        name);
            }
            else code_chunk_print(f, d, next_c, next_indent, 1);

            s = strchr(s, '}') + 1;
            invocation = strchr(s, CTRL);
        }
        /* print a whole line with no invocation, or the remainder of the line
         * following any number of invocations */
        fprintf(f, "%s\n", s); 
        indented = 0;
    }
}
~

~=load file into `char * source`
{
    FILE * source_file = fopen(filename, "r");
    if (source_file == NULL)
    {
        fprintf(stderr, "Error: could not open file %s\n", filename);
        exit(1);
    }
    
    /* get file size */
    fseek(source_file, 0L, SEEK_END);
    file_size = ftell(source_file);
    rewind(source_file);
    
    /* copy file into memory */
    source = malloc(1 + file_size); /* one added for null termination */
    fread(source, 1, file_size, source_file); 
    fclose(source_file);
    
    source[file_size] = 0;
}
~

~=includes
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
~

The ***_new functions enforce a few invariants: a `code_chunk` must always have
a name, and a `list` must always have a `code_chunk`.

~=data types
typedef struct List list;

typedef struct CodeChunk
{
    char * name;
    list * contents;
    int tangle;
} code_chunk;


code_chunk * code_chunk_new(char * name)
{
    code_chunk * chunk = malloc(sizeof(code_chunk));
    chunk->name     = name;
    chunk->contents = NULL;
    chunk->tangle   = 0;
    return chunk;
}

struct List
{
    void * data;
    struct List * successor;
};

list * list_new(void * d)
{
    list * l = malloc(sizeof(list));
    l->data = d;
    l->successor = NULL;
}

void list_append(list ** lst, void * addend)
{
    list * a = list_new(addend);
    if (*lst == NULL)
    {
        *lst = a;
    }
    else
    {
        list * l = *lst;
        while (l->successor != NULL) l = l->successor; /* go to the end of l */
        l->successor = a;
    }
}

/* http://www.cse.yorku.ca/~~oz/hash.html */
unsigned long hash(unsigned char *str)
{
    unsigned long hash = 5381;
    int c;

    while (c = *str++) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */

    return hash;
}

typedef struct Dict
{
    list ** array;
    size_t size;
} dict;

dict * dict_new(size_t size)
{
    dict * d = malloc(sizeof(dict));
    d->array = malloc(size * sizeof(list));
    memset(d->array, (size_t)NULL, size * sizeof(list));
    d->size = size;
}

void dict_add(dict * d, code_chunk * c)
{
    unsigned long h = hash(c->name) % d->size;
    list_append(&(d->array[h]), (void *) c);
}

code_chunk * dict_get(dict * d, char * name)
{
    unsigned long h = hash(name) % d->size;
    list * l = d->array[h];
    while (l != NULL)
    {
        code_chunk * c = l->data;
        if (strcmp(name, c->name) == 0) return c;
        else l = l->successor;
    }
    return NULL;
}

~

~=parse command line arguments
if (argc < 2 || *argv[1] == '-' /* assume -h */) 
{
    printf("%s", help);
    exit(0);
}
char * filename = argv[1];
~

~=functions
~{duplicate line}
~{extract invocation name}
~{code chunk print}
~

Since the control sequence leader character can be changed with 'ATSIGN:',
it's necessary to swap all the ATSIGNs that are found while extracting to
some stable character to prevent bugs when tangling and weaving. It is
assumed that ascii 7 (^G, BEL) will never occur in any source code file,
so we can transliterate ATSIGNs to 7 without having to worry about escapes.
If anyone ever tries to run `lilit` on a file with actual ascii 7 embedded in
the text, it will undoubtedly cause errors. If this ever happens, the
solution would be to detect actual ascii 7 while extracting and embed some
kind of escape sequence.

~=globals
char ATSIGN = 64; /* ascii for at sign */
const char CTRL = 7; /* ascii ^G, aka BEL */
int line_number = 0;
~

~=definitions
~{includes}
~{globals}
~{data types}
~{functions}
~{markup help text}
~

~=setup
~{variables}
~{parse command line arguments}
~{load file into `char * source`}
~{allocate additional memory}
~

~=variables
int file_size;
char * source;
dict * d;
list * tangles = NULL;
~

~=allocate additional memory
d = dict_new(128); /* for storing chunks */
~

